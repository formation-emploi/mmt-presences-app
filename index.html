<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Présences MMT</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Load PDF Libraries with CDN fallback -->
    <script src="resources/pdf.min.js"
        onerror="this.src='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js'"></script>
    <script src="resources/pdf-lib.min.js" onerror="this.src='https://unpkg.com/pdf-lib/dist/pdf-lib.min.js'"></script>
    <script>
        // Fallback for Worker if local fails
        function setupPdfWorker() {
            if (typeof pdfjsLib !== 'undefined') {
                const localWorker = 'resources/pdf.worker.min.js';
                const cdnWorker = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

                if (window.location.href.includes('about:srcdoc')) {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = cdnWorker;
                } else {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = localWorker;
                }
            }
        }
        window.addEventListener('DOMContentLoaded', setupPdfWorker);
    </script>

    <style>
        :root {
            --primary: #d32f2f;
            --primary-dark: #b71c1c;
            --primary-light: #ffcdd2;
            --bg-color: #f4f6f8;
            --text-color: #333;
            --card-bg: #ffffff;
            --border-radius: 12px;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        /* Layout */
        .navbar {
            background-color: var(--card-bg);
            padding: 1rem 3rem;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 4px solid var(--primary);
        }

        .nav-brand {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .nav-logo {
            height: 50px;
            width: auto;
        }

        .nav-links {
            display: flex;
            gap: 1.5rem;
        }

        .nav-link {
            text-decoration: none;
            color: #555;
            font-weight: 600;
            transition: all 0.3s;
            padding: 0.6rem 1.2rem;
            border-radius: 8px;
        }

        .nav-link:hover,
        .nav-link.active {
            color: white;
            background-color: var(--primary);
        }

        .container {
            max-width: 1400px;
            margin: 3rem auto;
            padding: 0 2rem 3rem 2rem;
            /* Added bottom padding for footer */
        }

        .view-section {
            animation: fadeIn 0.4s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Headers & Actions */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            background: white;
            padding: 1.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }

        .section-header h1 {
            font-size: 1.8rem;
            color: #1a1a1a;
            font-weight: 700;
        }

        .actions {
            display: flex;
            gap: 1rem;
        }

        /* Buttons */
        .btn-primary,
        .btn-secondary {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.95rem;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
            box-shadow: 0 4px 6px rgba(211, 47, 47, 0.2);
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: white;
            border: 2px solid #eee;
            color: #555;
        }

        .btn-secondary:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .btn-sm {
            padding: 0.4rem 0.8rem;
            font-size: 0.85rem;
        }

        /* Cards */
        .grid-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 2rem;
        }

        .participant-card {
            background: var(--card-bg);
            padding: 2rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            border-left: 5px solid var(--primary);
            transition: transform 0.2s;
        }

        .participant-card:hover {
            transform: translateY(-5px);
        }

        .participant-card h3 {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: #1a1a1a;
        }

        .card-details {
            margin: 1rem 0;
            font-size: 0.9rem;
            color: #666;
        }

        .schedule-badge {
            display: inline-block;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 2px;
            font-size: 0.8rem;
        }

        .schedule-badge.active {
            background: var(--primary-light);
            color: var(--primary-dark);
            font-weight: bold;
        }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(2px);
        }

        .modal-content {
            background: white;
            padding: 2.5rem;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 600px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        .modal-content h2 {
            margin-bottom: 1.5rem;
            color: var(--primary);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #333;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.8rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
        }

        /* Schedule Grid in Modal */
        .schedule-grid {
            display: grid;
            grid-template-columns: 100px repeat(2, 1fr);
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .schedule-header {
            font-weight: bold;
            font-size: 0.9rem;
            color: #666;
            text-align: center;
        }

        .schedule-row {
            display: contents;
        }

        .schedule-cell {
            text-align: center;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .tab-btn {
            background: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1rem;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            transition: all 0.3s;
        }

        .tab-btn.active {
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
        }

        /* Controls */
        .controls-bar {
            background: white;
            padding: 1rem 2rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            border-left: 5px solid var(--primary);
        }

        .date-nav {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .date-nav input {
            padding: 0.6rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            font-family: inherit;
        }

        /* Attendance Table */
        .attendance-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            background: white;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        .attendance-table th,
        .attendance-table td {
            padding: 1.2rem;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .attendance-table th {
            background-color: #f8f9fa;
            font-weight: 700;
            color: #444;
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 0.5px;
        }

        .att-comm {
            width: 100%;
            padding: 0.8rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            transition: border-color 0.2s;
        }

        .att-comm:focus {
            border-color: var(--primary);
            outline: none;
        }

        /* Success Mark */
        .check-mark {
            color: var(--primary);
            font-size: 1.8rem;
            font-weight: bold;
            margin-left: 1rem;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .check-mark.visible {
            opacity: 1;
        }

        /* Dashboard Calendar Table */
        .calendar-container {
            overflow-x: auto;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 1rem;
            margin-bottom: 2rem;
        }

        .calendar-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .calendar-table th {
            background: var(--primary);
            color: white;
            padding: 10px 4px;
            border: 1px solid #b71c1c;
        }

        .calendar-table td {
            border: 1px solid #e0e0e0;
            padding: 4px;
            text-align: center;
            min-width: 25px;
        }

        .calendar-table .name-col {
            text-align: left;
            padding: 0 10px;
            font-weight: bold;
            min-width: 150px;
            background: #fff;
            border-right: 2px solid #eee;
        }

        .calendar-table .period-col {
            text-align: center;
            font-weight: 600;
            font-size: 0.8rem;
            color: #666;
            background: #fcfcfc;
            width: 40px;
        }

        .calendar-table .weekend {
            background-color: #f9f9f9;
        }

        /* Cell Colors */
        .cell-x {
            background-color: #ffebee;
            color: #c62828;
            font-weight: bold;
        }

        .cell-other {
            border: 2px solid var(--primary);
            background-color: #fff;
            color: var(--primary-dark);
            font-weight: bold;
        }

        .cell-unknown {
            background-color: #fff3e0;
            color: #ef6c00;
            font-weight: bold;
            border: 2px solid red !important;
        }

        .cell-disabled {
            background-color: #e0e0e0 !important;
            color: #999;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .modal>div {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 2rem;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        .modal h2 {
            margin-bottom: 1.5rem;
            color: var(--primary);
        }

        .modal .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid #eee;
        }
    </style>
</head>

<body>
    <div id="sandbox-warning"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(255,255,255,0.95); z-index:9999; padding:2rem; text-align:center; font-family:sans-serif;">
        <div
            style="max-width:600px; margin:100px auto; padding:2rem; border:2px solid #d32f2f; border-radius:12px; background:white; box-shadow:0 10px 25px rgba(0,0,0,0.1);">
            <h2 style="color:#d32f2f; margin-bottom:1rem;">⚠️ Mode Aperçu SharePoint Détecté</h2>
            <p style="font-size:1.1rem; margin-bottom:1.5rem;">L'application est actuellement ouverte dans un "Aperçu"
                restreint qui bloque certaines fonctionnalités importantes.</p>
            <p style="margin-bottom:1.5rem;"><strong>Pour le bon fonctionnement de l'application :</strong></p>
            <ol style="text-align:left; margin-bottom:1.5rem; display:inline-block;">
                <li><strong>Ne cliquez pas directement</strong> sur le fichier (cela ouvre souvent l'aperçu restreint)
                </li>
                <li>Faites un <strong>clic droit</strong> sur le fichier <code>MMT_App_Final.aspx</code></li>
                <li>Sélectionnez <strong>Ouvrir</strong> &rarr; <strong>Ouvrir dans le navigateur</strong></li>
                <li>L'application devrait s'ouvrir en plein écran et fonctionner normalement</li>
                <li>Si SharePoint affiche un avertissement de sécurité, cliquez sur <strong>"Autoriser"</strong></li>
            </ol>
            <div style="margin-top:2rem;">
                <button onclick="document.getElementById('sandbox-warning').style.display='none'"
                    style="padding:0.8rem 1.5rem; background:#d32f2f; color:white; border:none; border-radius:8px; cursor:pointer; font-weight:600;">Ignorer
                    (Risque d'erreurs)</button>
            </div>
        </div>
    </div>

    <script>
        // Sandbox detection
        (function () {
            if (window.location.href.includes('about:srcdoc') || window.name === 'ms-viewer-iframe') {
                document.addEventListener('DOMContentLoaded', function () {
                    document.getElementById('sandbox-warning').style.display = 'block';
                });
            }
        })();
    </script>
    <nav class="navbar">
        <div class="nav-brand">
            <img src="logo.png"
                onerror="this.src='./logo.png'; this.onerror=function(){this.src='Picto_perso _FE en tête simpli.png'; this.onerror=function(){this.src='https://via.placeholder.com/150?text=MMT';}};"
                alt="Logo" class="nav-logo">
            Présences MMT
        </div>
        <div class="nav-links">
            <a href="#dashboard" class="nav-link active">Tableau de bord</a>
            <a href="#participants" class="nav-link">Participants</a>
            <a href="#classes" class="nav-link">Classes</a>
        </div>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
            <span id="user-email" style="color: #666; font-size: 0.9rem; margin-right: 0.5rem;"></span>
            <button onclick="window.firebaseLogout()" class="btn-secondary btn-sm"
                style="background: #dc2626; color: white; border: none;" title="Se déconnecter">
                🚪 Déconnexion
            </button>
            <button onclick="window.app.uploadGlobalTemplate()" class="btn-secondary btn-sm"
                style="background: #6c757d; color: white; border: none;" title="Définir le modèle PDF global">
                📄 Définir Modèle
            </button>
        </div>
    </nav>

    <main class="container">
        <!-- Dashboard View -->
        <section id="dashboard" class="view-section">
            <div class="section-header">
                <h1>Tableau de bord</h1>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                    <button id="btn-prev-month" class="btn-secondary"
                        style="font-weight: bold; padding: 0.5rem 1rem;">&lt;</button>
                    <input type="month" id="dashboard-month"
                        style="padding: 0.5rem 1rem; border-radius: 8px; border: 1px solid #ddd; font-family: 'Inter', sans-serif; font-size: 1rem; color: var(--primary); font-weight: 600; outline: none; cursor: pointer;">
                    <button id="btn-next-month" class="btn-secondary"
                        style="font-weight: bold; padding: 0.5rem 1rem;">&gt;</button>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                    <button onclick="window.app.generateMonthlyReport()" class="btn-primary"
                        title="Générer et imprimer tous les rapports">🖨️ Imprimer les MMT</button>
                </div>
            </div>

            <div id="dashboard-content">
                <!-- Calendar tables will be generated here -->
            </div>
        </section>

        <!-- Participants View -->
        <section id="participants" class="view-section" style="display: none;">
            <div class="section-header">
                <h1>Participants</h1>
                <div style="display: flex; gap: 1rem;">
                    <button onclick="window.app.openModal('modal-pdf-import')" class="btn-secondary">📄 Importer
                        PDF</button>
                    <!-- <button onclick="window.app.openNewParticipantModal()" class="btn-primary">+ Nouveau
                        Participant</button> -->
                </div>
            </div>

            <div class="tabs">
                <button class="tab-btn active" data-tab="active-participants">Participants Actifs</button>
                <button class="tab-btn" data-tab="archived-participants">Archives</button>
            </div>

            <div id="tab-active-participants" class="tab-content" style="display: block;">
                <!-- Batch Actions for Active Participants -->
                <div
                    style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 8px;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="cb-select-all-participants"
                            onchange="window.app.toggleSelectAllParticipants(this)">
                        <strong>Tout sélectionner</strong>
                    </label>
                    <button onclick="window.app.deleteSelectedParticipants()" class="btn-secondary"
                        style="color: var(--danger); border-color: var(--danger);">
                        🗑️ Supprimer la sélection
                    </button>
                </div>

                <div id="participants-list" class="grid-list">
                    <!-- Active participants will be loaded here -->
                </div>
            </div>


            <div id="tab-archived-participants" class="tab-content" style="display: none;">
                <div
                    style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding: 0.75rem; background: #f5f5f5; border-radius: 8px;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="cb-select-all-archived"
                            onchange="window.app.toggleSelectAllArchived(this)">
                        <strong>Tout sélectionner</strong>
                    </label>
                    <button onclick="window.app.deleteSelectedArchived()" class="btn-secondary"
                        style="color: var(--danger); border-color: var(--danger);">
                        🗑️ Supprimer la sélection
                    </button>
                </div>

                <div id="archived-participants-list" class="grid-list">
                    <!-- Archived participants will be loaded here -->
                </div>
            </div>
        </section>

        <!-- Classes View -->
        <section id="classes" class="view-section" style="display: none;">
            <div class="section-header">
                <h1>Classes</h1>
                <button onclick="window.app.openModal('modal-class')" class="btn-primary">+ Nouvelle Classe</button>
            </div>
            <div id="classes-list" class="grid-list">
                <!-- Classes will be loaded here -->
            </div>
        </section>

        <!-- Class Details View -->
        <section id="class-details" class="view-section" style="display: none;">
            <div class="section-header">
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <button id="btn-back-classes" class="btn-secondary">&larr;</button>
                    <h1 id="class-details-title">Détails Classe</h1>
                </div>
                <button onclick="window.app.openManageParticipantsModal()" class="btn-secondary">👥 Gérer
                    Participants</button>
            </div>

            <div class="tabs">
                <button class="tab-btn active" data-tab="attendance">Présences</button>
                <button class="tab-btn" data-tab="students">Liste Participants</button>
            </div>

            <div id="tab-attendance" class="tab-content">
                <div class="controls-bar">
                    <div class="date-nav">
                        <button id="btn-prev-date" class="btn-secondary" title="Jour précédent (saut week-end)"
                            onclick="window.app.handlePrevDate(event)">◀</button>
                        <input type="date" id="attendance-date"
                            style="font-family:'Inter'; font-weight:600; color:var(--primary);">
                        <button id="btn-next-date" class="btn-secondary" title="Jour suivant (saut week-end)"
                            onclick="window.app.handleNextDate(event)">▶</button>

                    </div>
                    <div style="display: flex; align-items: center;">
                        <button class="btn-primary" style="padding: 1rem 2rem; font-size: 1.1rem;"
                            onclick="window.saveAttendance()">
                            Présences contrôlées
                        </button>
                        <span id="attendance-check" style="display: none;"></span>
                    </div>
                </div>
                <div id="attendance-grid">
                    <!-- Attendance grid -->
                </div>
            </div>

            <div id="tab-students" class="tab-content" style="display: none;">
                <div id="class-participants-list" class="grid-list">
                    <!-- Class participants -->
                </div>
            </div>
        </section>
    </main>

    <!-- Modal Participant -->
    <div id="modal-participant" class="modal">
        <div>
            <h2 id="modal-p-title">Nouveau Participant</h2>
            <form id="form-participant" onsubmit="window.app.handleParticipantSubmit(event)">
                <input type="hidden" id="p-id">
                <div class="form-group">
                    <label>Prénom</label>
                    <input type="text" id="p-firstname" required>
                </div>
                <div class="form-group">
                    <label>Nom</label>
                    <input type="text" id="p-lastname" required>
                </div>
                <div class="form-group">
                    <label>% de Travail</label>
                    <input type="number" id="p-work-percent" min="0" max="100" value="100">
                </div>
                <div class="form-group">
                    <label>Date de début</label>
                    <input type="date" id="p-date-start">
                </div>
                <div class="form-group">
                    <label>Date de fin</label>
                    <input type="date" id="p-date-end">
                </div>
                <div class="form-group" style="padding-top: 1rem; border-top: 1px dashed #eee;">
                    <label style="display:flex; align-items:center; gap:0.5rem; cursor:pointer;">
                        <strong>Interruption MMT</strong>
                        <input type="checkbox" id="p-interruption-mmt" onchange="
                            if (!this.checked) {
                                document.getElementById('p-interruption-date').value = '';
                                document.getElementById('p-interruption-reason').value = '';
                            }
                        ">
                    </label>
                </div>
                <div class="form-group">
                    <label>Date de l'interruption</label>
                    <input type="date" id="p-interruption-date">
                </div>
                <div class="form-group">
                    <label>Motif de l'interruption</label>
                    <textarea id="p-interruption-reason" rows="2" placeholder="Ex: Maladie, raisons personnelles, etc."
                        style="resize: vertical;"></textarea>
                </div>
                <div class="form-group">
                    <label>Horaire de présence</label>
                    <div class="schedule-grid">
                        <div class="schedule-header">Jour</div>
                        <div class="schedule-header">Matin</div>
                        <div class="schedule-header">Après-midi</div>

                        <div class="schedule-row">
                            <div>Lundi</div>
                            <div class="schedule-cell"><input type="checkbox" name="sched-1-am" checked></div>
                            <div class="schedule-cell"><input type="checkbox" name="sched-1-pm" checked></div>
                        </div>
                        <div class="schedule-row">
                            <div>Mardi</div>
                            <div class="schedule-cell"><input type="checkbox" name="sched-2-am" checked></div>
                            <div class="schedule-cell"><input type="checkbox" name="sched-2-pm" checked></div>
                        </div>
                        <div class="schedule-row">
                            <div>Mercredi</div>
                            <div class="schedule-cell"><input type="checkbox" name="sched-3-am" checked></div>
                            <div class="schedule-cell"><input type="checkbox" name="sched-3-pm" checked></div>
                        </div>
                        <div class="schedule-row">
                            <div>Jeudi</div>
                            <div class="schedule-cell"><input type="checkbox" name="sched-4-am" checked></div>
                            <div class="schedule-cell"><input type="checkbox" name="sched-4-pm" checked></div>
                        </div>
                        <div class="schedule-row">
                            <div>Vendredi</div>
                            <div class="schedule-cell"><input type="checkbox" name="sched-5-am" checked></div>
                            <div class="schedule-cell"><input type="checkbox" name="sched-5-pm" checked></div>
                        </div>
                    </div>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-secondary"
                        onclick="window.app.closeModal('modal-participant')">Annuler</button>
                    <button type="submit" class="btn-primary">Enregistrer</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal Class -->
    <div id="modal-class" class="modal">
        <div>
            <h2>Nouvelle Classe</h2>
            <form id="form-class" onsubmit="window.app.handleClassSubmit(event)">
                <input type="hidden" id="c-id">
                <div class="form-group">
                    <label>Nom de la classe</label>
                    <input type="text" id="c-name" required>
                </div>
                <div class="form-group">
                    <label>Description</label>
                    <input type="text" id="c-desc">
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-secondary"
                        onclick="window.app.closeModal('modal-class')">Annuler</button>
                    <button type="submit" class="btn-primary">Créer</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal Manage Class Participants -->
    <div id="modal-manage-participants" class="modal">
        <div>
            <h2>Gérer les Participants</h2>
            <p style="margin-bottom: 1rem; color: #666;">Cochez les participants à inclure dans cette classe.</p>
            <div id="manage-participants-list"
                style="max-height: 300px; overflow-y: auto; margin-bottom: 1.5rem; border: 1px solid #eee; padding: 1rem; border-radius: 8px;">
                <!-- Checkboxes generated by JS -->
            </div>
            <div class="form-actions">
                <button type="button" class="btn-secondary"
                    onclick="window.app.closeModal('modal-manage-participants')">Annuler</button>
                <button type="button" class="btn-primary" onclick="window.app.saveClassParticipants()">Mettre à
                    jour</button>
            </div>
        </div>
    </div>

    <!-- Modal Import PDF -->
    <div id="modal-pdf-import" class="modal">
        <div>
            <h2>Importer depuis PDF</h2>
            <p style="margin-bottom: 1rem; color: #666;">Sélectionnez un ou plusieurs formulaires PDF à importer.</p>
            <form id="form-import-pdf" onsubmit="window.app.handlePDFImport(event)">
                <div class="form-group">
                    <label>Fichiers PDF</label>
                    <input type="file" id="pdf-file" accept=".pdf" multiple
                        onchange="window.app.handlePDFSelection(event)">
                </div>
                <div id="import-preview" style="margin-top: 1rem;"></div>
                <div class="form-actions">
                    <button type="button" class="btn-secondary" id="btn-cancel-import"
                        onclick="window.app.closeModal('modal-pdf-import')">Annuler</button>
                    <button type="submit" class="btn-primary">Importer</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal Print Selection -->
    <div id="modal-print-selection" class="modal">
        <div>
            <h2>Imprimer les MMT</h2>
            <p style="margin-bottom: 1rem; color: #666;">Sélectionnez les classes ou participants à inclure dans
                l'impression.</p>
            <div id="print-class-selection-list"
                style="max-height: 300px; overflow-y: auto; margin-bottom: 1.5rem; border: 1px solid #eee; padding: 1rem; border-radius: 8px;">
                <!-- Checkboxes generated by JS -->
            </div>
            <div class="form-actions">
                <button type="button" class="btn-secondary"
                    onclick="window.app.closeModal('modal-print-selection')">Annuler</button>
                <button type="button" class="btn-primary"
                    onclick="window.app.confirmPrintSelection()">Continuer</button>
            </div>
        </div>
    </div>

    <!-- Modal Date Selection -->
    <div id="modal-date-selection" class="modal" style="z-index: 2000;">
        <div style="max-width: 400px;">
            <h2>Date de signature</h2>
            <p style="margin-bottom: 1.5rem; color: #666;">Veuillez choisir ou saisir la date de signature.</p>
            <div class="form-group">
                <label>Date</label>
                <input type="date" id="input-signature-date" style="font-size: 1.1rem; padding: 0.5rem;">
            </div>

            <!-- Signature Selection -->
            <div class="form-group" style="padding-top: 1rem; border-top: 1px dashed #eee; margin-top: 1rem;">
                <label><strong>✍️ Signature</strong></label>
                <div style="display: flex; gap: 0.5rem; align-items: center; margin-top: 0.5rem;">
                    <select id="select-signature" style="flex: 1; padding: 0.5rem; font-size: 1rem;">
                        <option value="">Aucune signature</option>
                        <!-- Signatures will be loaded here -->
                    </select>
                    <button type="button" class="btn-secondary btn-sm" onclick="window.app.openSignatureManager()"
                        title="Gérer les signatures">
                        ⚙️
                    </button>
                </div>
                <div id="signature-preview"
                    style="margin-top: 0.5rem; padding: 0.5rem; background: #f9f9f9; border-radius: 4px; min-height: 40px; display: none;">
                    <img id="signature-preview-img" style="max-width: 100%; max-height: 60px; display: block;" />
                </div>
            </div>

            <div class="form-group" style="padding-top: 1rem; border-top: 1px dashed #eee; margin-top: 1rem;">
                <label style="display:flex; align-items:center; gap:0.5rem; cursor:pointer;">
                    <strong>Correction</strong>
                    <input type="checkbox" id="input-is-correction">
                </label>
                <p style="font-size: 0.85rem; color: #666; margin-top: 0.2rem;">Coche la case "Remplace le formulaire
                    précédent"</p>
            </div>
            <div class="form-actions">
                <button type="button" class="btn-secondary"
                    onclick="window.app.resolveDateSelection(null)">Annuler</button>
                <button type="button" class="btn-primary"
                    onclick="window.app.resolveDateSelection({ date: document.getElementById('input-signature-date').value, isCorrection: document.getElementById('input-is-correction').checked, signatureId: document.getElementById('select-signature').value })">Confirmer</button>
            </div>
        </div>
    </div>

    <!-- Modal Load Data -->
    <div id="modal-load-data" class="modal">
        <div>
            <h2>📤 Charger des données</h2>
            <p style="margin-bottom: 1rem; color: #666;">
                Sélectionnez un fichier JSON de sauvegarde pour restaurer vos données.
            </p>
            <div
                style="padding: 1rem; background: #fff3cd; border-left: 4px solid #ffc107; margin-bottom: 1rem; border-radius: 4px;">
                <strong>⚠️ Attention :</strong> Cette action remplacera toutes les données actuelles.
                Assurez-vous d'avoir fait une sauvegarde avant de continuer.
            </div>
            <div class="form-group">
                <label>Fichier de sauvegarde (JSON)</label>
                <input type="file" id="data-file-input" accept=".json">
            </div>
            <div id="load-data-preview"
                style="margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; display: none;">
                <h3 style="font-size: 1rem; margin-bottom: 0.5rem;">Aperçu du fichier :</h3>
                <ul style="margin-left: 1.5rem; color: #666;">
                    <li>Participants : <strong id="preview-participants-count">0</strong></li>
                    <li>Classes : <strong id="preview-classes-count">0</strong></li>
                    <li>Présences : <strong id="preview-attendance-count">0</strong></li>
                </ul>
            </div>
            <div class="form-actions">
                <button type="button" class="btn-secondary"
                    onclick="window.app.closeModal('modal-load-data'); document.getElementById('data-file-input').value = '';">
                    Annuler
                </button>
                <button type="button" class="btn-primary" onclick="window.app.loadDatabaseFromFile()"
                    id="btn-confirm-load" disabled>
                    Charger les données
                </button>
            </div>
        </div>
    </div>

    <!-- Modal Signature Manager -->
    <div id="modal-signature-manager" class="modal" style="z-index: 2100;">
        <div style="max-width: 600px;">
            <h2>✍️ Gestion des Signatures</h2>
            <p style="margin-bottom: 1.5rem; color: #666;">Ajoutez et gérez vos signatures pour les insérer
                automatiquement dans les PDF.</p>

            <!-- Upload Section -->
            <div style="padding: 1rem; background: #f8f9fa; border-radius: 8px; margin-bottom: 1.5rem;">
                <h3 style="font-size: 1rem; margin-bottom: 0.75rem;">➕ Ajouter une nouvelle signature</h3>
                <div class="form-group">
                    <label>Nom de la signature</label>
                    <input type="text" id="new-signature-name" placeholder="Ex: Signature principale"
                        style="margin-bottom: 0.5rem;">
                </div>
                <div class="form-group">
                    <label>Fichier image (PNG, JPG)</label>
                    <input type="file" id="new-signature-file" accept="image/png,image/jpeg,image/jpg">
                </div>
                <button type="button" class="btn-primary btn-sm" onclick="window.app.uploadSignature()">
                    💾 Enregistrer la signature
                </button>
            </div>

            <!-- Signatures List -->
            <div>
                <h3 style="font-size: 1rem; margin-bottom: 0.75rem;">Signatures enregistrées</h3>
                <div id="signatures-list" style="max-height: 300px; overflow-y: auto;">
                    <!-- Signatures will be loaded here -->
                </div>
            </div>

            <div class="form-actions">
                <button type="button" class="btn-secondary"
                    onclick="window.app.closeModal('modal-signature-manager')">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modal Upload Signature -->
    <div id="modal-signature-upload" class="modal" style="z-index: 2100;">
        <div style="max-width: 500px;">
            <h2>📝 Image de signature</h2>
            <p style="margin-bottom: 1rem; color: #666;">
                Uploadez une image de signature qui sera insérée dans le champ #108 - 5.25 de tous les formulaires MMT.
            </p>
            <div
                style="padding: 1rem; background: #e3f2fd; border-left: 4px solid #2196F3; margin-bottom: 1rem; border-radius: 4px;">
                <strong>📌 Astuce :</strong> Pour un meilleur rendu, utilisez une image PNG transparente de la
                signature.
            </div>
            <div class="form-group">
                <label>Image de signature (PNG, JPG, ou JPEG)</label>
                <input type="file" id="signature-image-input" accept="image/png,image/jpeg,image/jpg">
            </div>
            <div id="signature-preview-container"
                style="margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; display: none;">
                <h3 style="font-size: 0.9rem; margin-bottom: 0.5rem;">Aperçu :</h3>
                <div
                    style="text-align: center; padding: 1rem; background: white; border: 2px dashed #ddd; border-radius: 4px;">
                    <img id="signature-preview-img" style="max-width: 100%; max-height: 150px;" alt="Aperçu signature">
                </div>
                <button type="button" class="btn-secondary btn-sm" onclick="window.app.clearSignature()"
                    style="margin-top: 0.5rem; width: 100%;">
                    🗑️ Effacer
                </button>
            </div>
            <div
                style="padding: 1rem; background: #fff3cd; border-left: 4px solid #ffc107; margin-top: 1rem; border-radius: 4px;">
                <strong>ℹ️ Note :</strong> Vous pouvez continuer sans signature (le champ restera vide) ou en uploader
                une maintenant.
            </div>
            <div class="form-actions">
                <button type="button" class="btn-secondary" onclick="window.app.continueWithoutSignature()">
                    Continuer sans signature
                </button>
                <button type="button" class="btn-primary" onclick="window.app.continueWithSignature()"
                    id="btn-confirm-signature">
                    📝 Utiliser cette signature
                </button>
            </div>
        </div>
    </div>

    <script id="app-scripts">
        // Initialize global app object
        window.app = window.app || {};

        /**
         * Attendance Service
         */
        const ATTENDANCE_CODES = {
            '': { code: '', label: '(Vide)', description: 'Effacer / Aucune sélection', requiresComment: false },
            'X': { code: 'X', label: 'Sur place', description: 'PARTICIPATION SUR PLACE : le participant est présent', requiresComment: false },
            'O': { code: 'O', label: 'En ligne', description: 'PARTICIPATION EN LIGNE', requiresComment: false },
            'A': { code: 'A', label: 'Vacances', description: 'VACANCES : jours sans contrôle accordés par l\'ORP', requiresComment: false },
            'B': { code: 'B', label: 'Maladie/Grossesse', description: 'MALADIE, GROSSESSE : certificat médical requis', requiresComment: false },
            'C': { code: 'C', label: 'Accident', description: 'ACCIDENT : certificat médical requis dès le 4e jour', requiresComment: false },
            'D': { code: 'D', label: 'Congé maternité/parental', description: 'CONGÉ MATERNITÉ, CONGÉ DE L\'AUTRE PARENT', requiresComment: false },
            'E': { code: 'E', label: 'Service militaire/civil', description: 'SERVICE MILITAIRE, SERVICE CIVIL', requiresComment: false },
            'F': { code: 'F', label: 'Gain intermédiaire', description: 'GAIN INTERMÉDIAIRE : auprès d\'un employeur', requiresComment: false },
            'G': { code: 'G', label: 'Autres absences justifiées', description: 'AUTRES ABSENCES JUSTIFIÉES AVEC INDEMNITÉ DE CHÔMAGE', requiresComment: true },
            'H': { code: 'H', label: 'Jours fériés/Fermeture', description: 'JOURS FÉRIÉS, VACANCES D\'ENTREPRISE', requiresComment: false },
            'I': { code: 'I', label: 'Absence non justifiée', description: 'ABSENCES NON JUSTIFIÉES', requiresComment: false }
        };

        class AttendanceService {
            async saveAttendance(attendanceRecords) {
                const items = attendanceRecords.map(record => {
                    const id = `${record.classId}_${record.date}_${record.participantId}`;
                    return { ...record, id };
                });

                if (dbService.saveAttendances) return await dbService.saveAttendances(items);

                const promises = items.map(item => dbService.update(STORES.ATTENDANCE, item));
                return Promise.all(promises);
            }

            async getAttendance(classId, date) {
                let all = [];
                if (dbService.getAttendances) all = await dbService.getAttendances();
                else all = await dbService.getAll(STORES.ATTENDANCE);
                return all.filter(r => r.classId === classId && r.date === date);
            }

            async markAsChecked(classId, date) {
                const checkId = `check_${classId}_${date}`;
                const data = { id: checkId, classId, date, checked: true, checkedAt: new Date().toISOString() };

                // Utiliser la méthode appropriée selon l'adaptateur
                if (dbService.saveAttendances) {
                    return await dbService.saveAttendances([data]);
                } else if (dbService.update) {
                    return await dbService.update(STORES.ATTENDANCE, data);
                } else if (dbService.add) {
                    return await dbService.add(STORES.ATTENDANCE, data);
                }
            }

            async isChecked(classId, date) {
                const checkId = `check_${classId}_${date}`;
                try {
                    let allRecords = [];
                    if (dbService.getAttendances) {
                        allRecords = await dbService.getAttendances();
                    } else if (dbService.getAll) {
                        allRecords = await dbService.getAll(STORES.ATTENDANCE);
                    }
                    const record = allRecords.find(r => r.id === checkId);
                    return record && record.checked;
                } catch (error) { return false; }
            }
        }
        window.attendanceService = new AttendanceService();
        window.ATTENDANCE_CODES = ATTENDANCE_CODES;


        /**
         * PDF Generator Service
         */
        const PDF_MAPPING = {
            monthYear: 'Textfeld 98',
            currentDate: 'Textfeld 103',
            location: '5.19',
            comments: '1.172',
            presenceType: { name: 'Optionsfeld 6', value: 'Auswahl1' },
            interruption: { name: 'Optionsfeld 70', value: 'selection2', date: '1.63' },
            attendanceFields: [
                '2.10146', '2.10147', '2.3015', '2.3016', '2.2031', '2.2032', '2.355', '2.356', '2.335', '2.336',
                '2.347', '2.348', '2.2039', '2.2040', '2.363', '2.364', '2.10150', '2.10151', '2.3019', '2.344',
                '2.2035', '2.2036', '2.359', '2.360', '2.339', '2.340', '2.351', '2.352', '2.3011', '2.3012',
                '2.367', '2.368', '2.10148', '2.10149', '2.3017', '2.3018', '2.2033', '2.2034', '2.357', '2.358',
                '2.337', '2.338', '2.349', '2.350', '2.343', '2.3010', '2.365', '2.366', '2.10152', '2.10153',
                '2.345', '2.346', '2.2037', '2.2038', '2.361', '2.362', '2.341', '2.342', '2.353', '2.354', '2.3013', '2.3014'
            ]
        };

        async function generatePDF(participant, attendanceData, templateBytes, signatureDate, isCorrection = false, signatureId = null) {
            if (typeof PDFLib === 'undefined') throw new Error('La librairie PDFLib n\'est pas chargée.');
            try {
                const pdfDoc = await PDFLib.PDFDocument.load(templateBytes);
                const helveticaFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                const form = pdfDoc.getForm();

                // NEW: Restore original PDF data if available (from parsePDF)
                if (participant.pdfData) {
                    console.log('📝 Restauration des données PDF pour:', participant.firstName);
                    try {
                        const pdfData = typeof participant.pdfData === 'string' ? JSON.parse(participant.pdfData) : participant.pdfData;
                        Object.entries(pdfData).forEach(([fieldName, value]) => {
                            try {
                                const field = form.getField(fieldName);
                                if (field instanceof PDFLib.PDFTextField) {
                                    field.setText(value);
                                } else if (field instanceof PDFLib.PDFCheckBox) {
                                    if (value === true) field.check();
                                    else field.uncheck();
                                } else if (field instanceof PDFLib.PDFRadioGroup && value) {
                                    field.select(value);
                                }
                            } catch (e) {
                                // Ignore fields that might be missing in the template or read-only
                            }
                        });
                    } catch (e) {
                        console.warn('⚠️ Erreur restauration données PDF:', e);
                    }
                }

                let monthYearStr = '';
                const dashboardMonth = document.getElementById('dashboard-month');
                if (dashboardMonth && dashboardMonth.value) {
                    const [y, m] = dashboardMonth.value.split('-');
                    monthYearStr = `${m}${y}`;
                } else {
                    const now = new Date();
                    monthYearStr = `${String(now.getMonth() + 1).padStart(2, '0')}${now.getFullYear()}`;
                }
                trySetField(form, PDF_MAPPING.monthYear, monthYearStr, helveticaFont);

                let dateStr;
                if (signatureDate) {
                    dateStr = signatureDate.replace(/\./g, '');
                } else {
                    const now = new Date();
                    dateStr = `${String(now.getDate()).padStart(2, '0')}${String(now.getMonth() + 1).padStart(2, '0')}${now.getFullYear()}`;
                }
                trySetField(form, PDF_MAPPING.currentDate, dateStr, helveticaFont);

                if (isCorrection) {
                    try {
                        const field = form.getField('Kontrollkästchen 7');
                        if (field instanceof PDFLib.PDFCheckBox) {
                            field.check();
                        } else if (field instanceof PDFLib.PDFRadioGroup) {
                            const options = field.getOptions();
                            const match = options.find(o => ['yes', 'oui', '1', 'on', 'selection2', 'auswahl2'].includes(o.toLowerCase()));
                            if (match) field.select(match);
                        }
                    } catch (e) { console.warn('Could not check Correction box:', e); }
                }

                trySetField(form, PDF_MAPPING.location, 'Porrentruy', helveticaFont);

                try { form.getRadioGroup('Optionsfeld 6').select('Auswahl1'); } catch (e) { }

                try {
                    const radioGroup = form.getRadioGroup('Optionsfeld 70');
                    const targetValue = participant.interruptionMMT ? 'Auswahl2' : 'Auswahl1';
                    radioGroup.select(targetValue);
                } catch (e) { }

                if (participant.interruptionDate) {
                    try {
                        const [y, m, d] = participant.interruptionDate.split('-');
                        const formattedDate = `${d}${m}${y}`;
                        trySetField(form, PDF_MAPPING.interruption.date, formattedDate, helveticaFont);
                    } catch (e) { }
                }



                const [year, month] = (dashboardMonth && dashboardMonth.value) ? dashboardMonth.value.split('-') : [new Date().getFullYear(), String(new Date().getMonth() + 1).padStart(2, '0')];
                const daysInMonth = new Date(year, month, 0).getDate();
                let commentsList = [];
                let fieldIndex = 0;

                for (let d = 1; d <= 31; d++) {
                    if (d > daysInMonth) { fieldIndex += 2; continue; }
                    const dateKey = `${year}-${month}-${String(d).padStart(2, '0')}`;
                    const record = attendanceData.find(r => r.date === dateKey);
                    const amCode = record ? (record.morningCode === 'P' ? 'X' : (record.morningCode || '')) : '';
                    const pmCode = record ? (record.afternoonCode === 'P' ? 'X' : (record.afternoonCode || '')) : '';

                    if (fieldIndex < PDF_MAPPING.attendanceFields.length) trySetField(form, PDF_MAPPING.attendanceFields[fieldIndex], amCode, helveticaFont);
                    fieldIndex++;
                    if (fieldIndex < PDF_MAPPING.attendanceFields.length) trySetField(form, PDF_MAPPING.attendanceFields[fieldIndex], pmCode, helveticaFont);
                    fieldIndex++;

                    if (record && record.comment && record.comment.trim() !== '') {
                        const dayStr = String(d).padStart(2, '0');
                        commentsList.push(`${dayStr}.${month} "${record.comment}"`);
                    }
                }

                if (commentsList.length > 0) {
                    trySetField(form, PDF_MAPPING.comments, commentsList.join(' / '), helveticaFont);
                }

                // DEBUG MODE: Fill all unused text fields with their names
                const DEBUG_FILL_FIELDS = false; // Disabled - field 1.183 found!

                if (DEBUG_FILL_FIELDS) {
                    const usedFields = new Set(['Textfeld 98', 'Textfeld 103', '5.19', '1.172', '1.63', '5.25', '2.10146', '2.10147', '2.3015', '2.3016', '2.2031', '2.2032', '2.355', '2.356', '2.335', '2.336', '2.347', '2.348', '2.2039', '2.2040', '2.363', '2.364', '2.10150', '2.10151', '2.3019', '2.344', '2.2037', '2.2038', '2.3017', '2.3018', '2.10148', '2.10149', '2.339', '2.340', '2.351', '2.352']);

                    const allFields = form.getFields();
                    allFields.forEach(field => {
                        const fieldName = field.getName();
                        if (field.constructor.name === 'PDFTextField' && !usedFields.has(fieldName)) {
                            try {
                                trySetField(form, fieldName, `[${fieldName}]`, helveticaFont);
                            } catch (e) { }
                        }
                    });
                }


                // Write interruption reason to field 1.183
                if (participant.interruptionReason) {
                    try {
                        trySetField(form, '1.183', participant.interruptionReason, helveticaFont);
                    } catch (e) {
                        console.error('Could not set interruption reason:', e);
                    }
                }

                // Handle signature image
                const pages = pdfDoc.getPages();
                const firstPage = pages[0];

                // Position 2: Field 5.25 position - now for signature image
                if (signatureId) {
                    console.log('🔍 DEBUG: Tentative de chargement de la signature:', signatureId);
                    try {
                        let signatures = [];
                        if (dbService.getSignatures) {
                            signatures = await dbService.getSignatures();
                        } else if (dbService.getAll) {
                            signatures = await dbService.getAll('signatures');
                        }
                        console.log('🔍 DEBUG: Signatures trouvées:', signatures.length, signatures.map(s => s.id));
                        const signature = signatures.find(s => s.id === signatureId);
                        console.log('🔍 DEBUG: Signature sélectionnée:', signature ? 'Trouvée' : 'NON TROUVÉE');

                        if (signature && signature.imageData) {
                            console.log('🔍 DEBUG: ImageData présent, taille:', signature.imageData.length);
                            // Convert Base64 to bytes
                            const imageBytes = Uint8Array.from(atob(signature.imageData.split(',')[1]), c => c.charCodeAt(0));

                            // Embed image (support PNG and JPG)
                            let image;
                            if (signature.imageData.includes('image/png')) {
                                image = await pdfDoc.embedPng(imageBytes);
                                console.log('✅ DEBUG: Image PNG embedée');
                            } else {
                                image = await pdfDoc.embedJpg(imageBytes);
                                console.log('✅ DEBUG: Image JPG embedée');
                            }

                            // Use field 5.25 by getting its position
                            try {
                                const field = form.getTextField('5.25');

                                // Get field position and dimensions
                                const widgets = field.acroField.getWidgets();
                                if (widgets.length > 0) {
                                    const widget = widgets[0];
                                    const rect = widget.getRectangle();

                                    const signatureWidth = rect.width;
                                    const signatureHeight = rect.height;
                                    const imgDims = image.scale(1);
                                    const baseScale = Math.min(signatureWidth / imgDims.width, signatureHeight / imgDims.height);
                                    const scale = baseScale * 1.5; // Make signature 50% larger

                                    // Get the page number for this field
                                    const pageRef = widget.P();
                                    let targetPage = firstPage;

                                    // Try to find which page this field is on
                                    for (let i = 0; i < pages.length; i++) {
                                        if (pages[i].ref === pageRef) {
                                            targetPage = pages[i];
                                            break;
                                        }
                                    }

                                    targetPage.drawImage(image, {
                                        x: rect.x,
                                        y: rect.y - 8,  // Lower by 3mm (≈8 points)
                                        width: imgDims.width * scale,
                                        height: imgDims.height * scale
                                    });
                                }
                            } catch (fieldError) {
                                // Fallback to hardcoded position if field not found
                                console.warn('Could not find field 5.25, using fallback position');
                                const signatureWidth = 282;
                                const signatureHeight = 28.3;
                                const imgDims = image.scale(1);
                                const scale = Math.min(signatureWidth / imgDims.width, signatureHeight / imgDims.height);

                                // Use a different position - you'll need to adjust based on where field 5.25 actually is
                                firstPage.drawImage(image, {
                                    x: 100,  // Adjust this
                                    y: 700,  // Adjust this
                                    width: imgDims.width * scale,
                                    height: imgDims.height * scale
                                });
                            }
                        }
                    } catch (e) {
                        console.error('Error inserting signature:', e);
                    }
                }

                // Supprimer la page 3 si elle existe (nouvelle version du formulaire)
                try {
                    const pageCount = pdfDoc.getPageCount();
                    if (pageCount >= 3) {
                        pdfDoc.removePage(2); // Index 2 = page 3
                    }
                } catch (e) {
                    console.warn('⚠️ Impossible de supprimer la page 3:', e);
                }

                try { form.flatten(); } catch (e) { }
                return await pdfDoc.save();

            } catch (error) {
                console.error('Error generating PDF:', error);
                throw error;
            }
        }

        function trySetField(form, fieldName, value, font) {
            try {
                const field = form.getTextField(fieldName);
                field.setText(String(value));
                if (font) {
                    field.updateAppearances(font);
                    try {
                        const da = PDFLib.PDFString.of('/Helvetica 10 Tf 0 g');
                        field.acroField.dict.set(PDFLib.PDFName.of('DA'), da);
                    } catch (e) { }
                }
            } catch (e) { }
        }
        window.pdfGenerator = { generatePDF };


        /**
         * PDF Parser Service
         */
        const FIELD_MAPPING = {
            '1.2': 'lastName', '1.3': 'firstName', 'Textfeld 43': 'avsNumber', 'Textfeld 61': 'avsNumber',
            'Textfeld 42': 'birthDate', 'Textfeld 41': 'monthYear', '1.68': 'courseType',
            '1.49': 'dateStart', '1.48': 'dateEnd', '1.46': 'workPercent', '1.139': 'decisionNumber',
            '1.141': 'unemploymentOffice', '1.67': 'executionPlace', '1.4': 'organizerName',
            '1.32': 'organizerLastName', '1.56': 'organizerFirstName', '1.61': 'organizerPhone',
            '1.62': 'organizerEmail', 'Kontrollkästchen 6': 'noParticipation',
            'Kontrollkästchen 7': 'isCorrection', 'Optionsfeld 70': 'wasInterrupted',
            '1.63': 'interruptionDate', '5.19': 'signaturePlace', 'Textfeld 103': 'signatureDate',
            '5.25': 'signature'
        };

        const ATTENDANCE_FIELDS = {
            1: { am: '2.10146', pm: '2.10147' }, 2: { am: '2.10148', pm: '2.10149' },
            3: { am: '2.10150', pm: '2.10151' }, 4: { am: '2.10152', pm: '2.10153' },
            5: { am: '2.335', pm: '2.336' }, 6: { am: '2.337', pm: '2.338' },
            7: { am: '2.339', pm: '2.340' }, 8: { am: '2.341', pm: '2.342' },
            9: { am: '2.2031', pm: '2.2032' }, 10: { am: '2.2033', pm: '2.2034' },
            11: { am: '2.2035', pm: '2.2036' }, 12: { am: '2.2037', pm: '2.2038' },
            13: { am: '2.2039', pm: '2.2040' }, 14: { am: '2.343', pm: '2.3010' },
            15: { am: '2.3011', pm: '2.3012' }, 16: { am: '2.3013', pm: '2.3014' },
            17: { am: '2.3015', pm: '2.3016' }, 18: { am: '2.3017', pm: '2.3018' },
            19: { am: '2.3019', pm: '2.344' }, 20: { am: '2.345', pm: '2.346' },
            21: { am: '2.347', pm: '2.348' }, 22: { am: '2.349', pm: '2.350' },
            23: { am: '2.351', pm: '2.352' }, 24: { am: '2.353', pm: '2.354' },
            25: { am: '2.355', pm: '2.356' }, 26: { am: '2.357', pm: '2.358' },
            27: { am: '2.359', pm: '2.360' }, 28: { am: '2.361', pm: '2.362' },
            29: { am: '2.363', pm: '2.364' }, 30: { am: '2.365', pm: '2.366' },
            31: { am: '2.367', pm: '2.368' }
        };

        async function parsePDF(file) {
            if (typeof PDFLib === 'undefined') throw new Error('pdf-lib not loaded');
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                const form = pdfDoc.getForm();
                const fields = form.getFields();
                const fieldData = {};
                fields.forEach(field => {
                    const name = field.getName();
                    let value = '';
                    try {
                        if (typeof field.getText === 'function') value = field.getText() || '';
                        else if (typeof field.isChecked === 'function') value = field.isChecked();
                        else if (typeof field.getSelected === 'function') value = field.getSelected() || '';
                        if (!value && field.acroField && field.acroField.dict) {
                            const vEntry = field.acroField.dict.lookup(PDFLib.PDFName.of('V'));
                            if (vEntry) {
                                if (vEntry instanceof PDFLib.PDFString) value = vEntry.decodeText();
                                else if (vEntry instanceof PDFLib.PDFName) value = vEntry.asString();
                            }
                        }
                    } catch (e) { }
                    if (value) fieldData[name] = value;
                });

                const result = {
                    firstName: '', lastName: '', courseType: '', dateStart: '', dateEnd: '',
                    workPercent: 100, avsNumber: '', birthDate: '', monthYear: '',
                    attendance: { days: {}, comments: '' },
                    pdfData: JSON.stringify(fieldData) // Store all raw fields as JSON string to avoid Firestore limitations
                };

                for (const [fieldName, propertyName] of Object.entries(FIELD_MAPPING)) {
                    if (fieldData[fieldName]) result[propertyName] = fieldData[fieldName];
                }

                if (result.dateStart) result.dateStart = parseDate(result.dateStart);
                if (result.dateEnd) result.dateEnd = parseDate(result.dateEnd);
                if (result.birthDate) result.birthDate = parseDate(result.birthDate);
                if (result.workPercent) {
                    const match = String(result.workPercent).match(/(\d+)/);
                    result.workPercent = match ? parseInt(match[1]) : 100;
                }

                for (const [day, fieldNames] of Object.entries(ATTENDANCE_FIELDS)) {
                    const amValue = fieldData[fieldNames.am] || '';
                    const pmValue = fieldData[fieldNames.pm] || '';
                    if (amValue || pmValue) result.attendance.days[day] = { am: amValue, pm: pmValue };
                }

                if (!result.firstName || !result.lastName) {
                    const filenameData = extractFromFilename(file.name);
                    if (!result.firstName) result.firstName = filenameData.firstName;
                    if (!result.lastName) result.lastName = filenameData.lastName;
                    if (!result.courseType) result.courseType = filenameData.courseType;
                    if (!result.dateStart) result.dateStart = filenameData.dateStart;
                    if (!result.dateEnd) result.dateEnd = filenameData.dateEnd;
                }

                if (!result.firstName) result.firstName = '';
                return result;

            } catch (error) { throw error; }
        }

        function parseDate(dateStr) {
            if (!dateStr) return '';
            dateStr = dateStr.trim();
            let match = dateStr.match(/(\d{1,2})\.(\d{1,2})\.(\d{4})/);
            if (match) return `${match[3]}-${match[2].padStart(2, '0')}-${match[1].padStart(2, '0')}`;
            match = dateStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
            if (match) return `${match[3]}-${match[2].padStart(2, '0')}-${match[1].padStart(2, '0')}`;
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) return dateStr;
            match = dateStr.match(/^(\d{2})(\d{2})(\d{4})$/);
            if (match) return `${match[3]}-${match[2]}-${match[1]}`;
            return dateStr;
        }

        function extractFromFilename(filename) {
            const result = { firstName: '', lastName: '', courseType: '', dateStart: '', dateEnd: '' };
            const parts = filename.replace('.pdf', '').split('_');
            if (parts.length >= 4) {
                if (parts[1]) result.courseType = parts[1];
                if (parts[2]) {
                    const { firstName, lastName } = splitFullName(parts[2]);
                    result.firstName = firstName;
                    result.lastName = lastName;
                }
                if (parts[3] && parts[3].match(/(\d{4})(\d{2})(\d{2})/)) {
                    const dateMatch = parts[3].match(/(\d{4})(\d{2})(\d{2})/);
                    result.dateStart = `${dateMatch[1]}-${dateMatch[2]}-01`;
                    const lastDay = new Date(parseInt(dateMatch[1]), parseInt(dateMatch[2]), 0).getDate();
                    result.dateEnd = `${dateMatch[1]}-${dateMatch[2]}-${String(lastDay).padStart(2, '0')}`;
                }
            }
            return result;
        }

        function splitFullName(fullName) {
            const capitals = [];
            for (let i = 0; i < fullName.length; i++) {
                if (fullName[i] === fullName[i].toUpperCase() && /[A-ZÀ-Ÿ]/.test(fullName[i])) capitals.push(i);
            }
            if (capitals.length >= 2) {
                const splitIndex = capitals[capitals.length - 1];
                return { lastName: fullName.substring(0, splitIndex), firstName: fullName.substring(splitIndex) };
            }
            return { firstName: '', lastName: fullName };
        }


        /**
         * Main Application Logic
         */

        // Database Constants
        const DB_NAME = 'PresenceAppDB';
        const DB_VERSION = 4;
        const STORES = {
            PARTICIPANTS: 'participants',
            CLASSES: 'classes',
            ATTENDANCE: 'attendance'
        };

        // Database Service (SharePoint/JSON Mode with LocalStorage Fallback)
        const jsonDbService = {
            data: {
                participants: [],
                classes: [],
                attendance: [],
                archivedParticipants: [],
                signatures: []
            },
            jsonUrl: 'mmt_db.json',
            storageKey: 'mmt_db_backup',

            // FLAG: Use SharePoint Lists Backend?
            useSharePointLists: false,
            baseUrl: '',

            async init() {
                console.log('🔄 Initializing DB Service...');

                // 1. Detect SharePoint Environment & Site URL
                this.baseUrl = await this.detectBaseUrl();

                if (this.baseUrl || this.baseUrl === '') {
                    try {
                        const spContext = await fetch(`${this.baseUrl}_api/contextinfo`, {
                            method: 'POST',
                            headers: { 'Accept': 'application/json;odata=verbose' }
                        });
                        if (spContext.ok) {
                            this.useSharePointLists = true;
                            console.log(`🌐 SharePoint Environment Detected at ${this.baseUrl}`);
                            this.updateStatus('connected');
                            await this.loadFromSharePointLists();
                            if (this.data.participants.length === 0 && this.data.classes.length === 0) {
                                console.log('⚠️ Lists empty or missing. Trying file fallback for migration...');
                                await this.loadFromFile();
                            }
                            return this.data;
                        }
                    } catch (e) {
                        console.log('👤 Connection check failed:', e);
                        this.updateStatus('local');
                    }
                } else {
                    console.log('👤 Standalone/Local Mode detected (No SP API found).');
                    this.updateStatus('local');
                }

                // 2. Fallback: Local/File Mode
                await this.loadFromFile();
                if (!this.useSharePointLists) this.updateStatus('local');

                // 3. Auto-archive expired participants
                await this.archiveExpiredParticipants();

                return this.data;
            },

            async archiveExpiredParticipants() {
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                // Keep active until the end of the current month
                // Archive only if endDate is strictly before the 1st of the current month
                const archiveThreshold = new Date(today.getFullYear(), today.getMonth(), 1);

                const toArchive = this.data.participants.filter(p => {
                    if (!p.dateEnd) return false;
                    const endDate = new Date(p.dateEnd);
                    return endDate < archiveThreshold;
                });

                if (toArchive.length > 0) {
                    console.log(`📦 Archiving ${toArchive.length} expired participant(s)`);

                    if (!this.data.archivedParticipants) this.data.archivedParticipants = [];

                    // Add to archive (checking unicity just in case)
                    toArchive.forEach(p => {
                        if (!this.data.archivedParticipants.find(ap => ap.id === p.id)) {
                            this.data.archivedParticipants.push(p);
                        }
                    });

                    // Remove from active participants
                    this.data.participants = this.data.participants.filter(p => {
                        if (!p.dateEnd) return true;
                        const endDate = new Date(p.dateEnd);
                        return endDate >= archiveThreshold;
                    });

                    // Save changes
                    await this.save();
                }
            },

            async detectBaseUrl() {
                const paths = ['', '../', '../../', '../../../'];
                for (const path of paths) {
                    try {
                        const r = await fetch(`${path}_api/contextinfo`, {
                            method: 'POST',
                            headers: { 'Accept': 'application/json;odata=verbose' }
                        });
                        if (r.ok || r.status === 403) return path;
                    } catch (e) { }
                }
                return null;
            },

            // --- FILE MODE METHODS ---
            async loadFromFile() {
                // 1. Charger depuis localStorage (fallback)
                const backup = localStorage.getItem(this.storageKey);
                if (backup) {
                    try { this.data = JSON.parse(backup); } catch (e) { }
                }

                // 2. Charger depuis Firestore si disponible
                if (window.firebaseDb && window.currentUser) {
                    try {
                        const { getDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
                        const userDataRef = doc(window.firebaseDb, 'users', window.currentUser.uid);
                        const docSnap = await getDoc(userDataRef);

                        if (docSnap.exists()) {
                            const firestoreData = docSnap.data();

                            // Helper to convert Base64 to ArrayBuffer
                            const base64ToArrayBuffer = (base64) => {
                                const binary_string = window.atob(base64);
                                const len = binary_string.length;
                                const bytes = new Uint8Array(len);
                                for (let i = 0; i < len; i++) {
                                    bytes[i] = binary_string.charCodeAt(i);
                                }
                                return bytes.buffer;
                            };

                            // Convertir les participants (restaurer ArrayBuffer depuis Base64)
                            const participants = (firestoreData.participants || []).map(p => {
                                if (p.isBase64Pdf && p.originalPdf && typeof p.originalPdf === 'string') {
                                    p.originalPdf = base64ToArrayBuffer(p.originalPdf);
                                    // p.isBase64Pdf = false; // Keep flag or remove, doesn't matter much internally
                                }
                                return p;
                            });

                            this.data = {
                                participants: participants,
                                classes: firestoreData.classes || [],
                                attendances: firestoreData.attendances || []
                            };
                            console.log('✅ Données chargées depuis Firestore');
                            // Sauvegarder aussi en localStorage pour le fallback
                            localStorage.setItem(this.storageKey, JSON.stringify(this.data));
                        } else {
                            console.log('ℹ️ Pas de données Firestore, utilisation de localStorage');
                        }
                    } catch (error) {
                        console.error('❌ Erreur chargement Firestore:', error);
                        // Continue avec localStorage
                    }

                    // Charger les signatures depuis la collection partagée
                    try {
                        const { getDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
                        const signaturesRef = doc(window.firebaseDb, 'shared', 'signatures');
                        const signaturesSnap = await getDoc(signaturesRef);

                        if (signaturesSnap.exists()) {
                            const signaturesData = signaturesSnap.data();
                            this.data.signatures = signaturesData.signatures || [];
                            console.log('✅ Signatures chargées depuis Firestore');
                            // Sauvegarder aussi en localStorage
                            localStorage.setItem(this.storageKey, JSON.stringify(this.data));
                        }
                    } catch (error) {
                        console.error('❌ Erreur chargement signatures Firestore:', error);
                    }
                }

                // 3. Charger depuis fichier JSON (ancien système)
                try {
                    const response = await fetch(`${this.jsonUrl}?t=${new Date().getTime()}`);
                    if (response.ok) {
                        const json = await response.json();
                        if (json) this.data = json;
                    }
                } catch (e) { }
            },

            // --- SHAREPOINT LIST METHODS ---
            async loadFromSharePointLists() {
                try {
                    const pParams = "$select=Title,JSON_Data&$top=5000";
                    const pResp = await fetch(`${this.baseUrl}_api/web/lists/getbytitle('MMT_Participants')/items?${pParams}`, { headers: { 'Accept': 'application/json;odata=verbose' } });
                    if (pResp.ok) {
                        const pData = await pResp.json();
                        this.data.participants = pData.d.results.map(r => JSON.parse(r.JSON_Data));
                    }

                    const cResp = await fetch(`${this.baseUrl}_api/web/lists/getbytitle('MMT_Classes')/items?${pParams}`, { headers: { 'Accept': 'application/json;odata=verbose' } });
                    if (cResp.ok) {
                        const cData = await cResp.json();
                        this.data.classes = cData.d.results.map(r => JSON.parse(r.JSON_Data));
                    }

                    const aResp = await fetch(`${this.baseUrl}_api/web/lists/getbytitle('MMT_Attendance')/items?${pParams}`, { headers: { 'Accept': 'application/json;odata=verbose' } });
                    if (aResp.ok) {
                        const aData = await aResp.json();
                        this.data.attendance = aData.d.results.map(r => JSON.parse(r.JSON_Data));
                    }
                    console.log('✅ Loaded from SharePoint Lists');
                } catch (e) {
                    console.warn('⚠️ Error loading Lists (Not installed?):', e);
                    this.showSaveIndicator('⚠️ Listes SharePoint introuvables. Cliquez sur CONFIGURER.');
                    const btn = document.querySelector('.btn-save-indicator');
                    if (btn) btn.onclick = () => window.app.installSharePointLists();
                    this.updateStatus('error');
                }
            },

            updateStatus(status) {
                const badge = document.getElementById('db-status-badge');
                // Target the container of the manual buttons (parent of the save button)
                const manualButtons = document.querySelector('.btn-save-indicator')?.parentElement;

                if (!badge) return;

                if (status === 'connected') {
                    badge.style.background = '#e8f5e9';
                    badge.style.color = '#2e7d32';
                    badge.innerHTML = '<span style="font-size: 1.2em;">🟢</span> Sync Cloud';
                    badge.title = "Vos données sont synchronisées en temps réel avec SharePoint.";
                    // Hide manual buttons in cloud mode
                    if (manualButtons) manualButtons.style.display = 'none';

                } else if (status === 'local') {
                    badge.style.background = '#e9ecef';
                    badge.style.color = '#6c757d';
                    badge.innerHTML = '<span style="font-size: 1.2em;">⚪</span> Mode Local';
                    badge.title = "Cliquez pour forcer la configuration SharePoint si vous êtes bien en ligne.";
                    badge.style.cursor = 'pointer';
                    badge.onclick = () => {
                        if (confirm('Forcer la tentative de connexion SharePoint ?\n(À faire uniquement si le fichier est hébergé sur un site SharePoint)')) {
                            window.app.installSharePointLists();
                        }
                    };
                    // Show buttons in local mode
                    if (manualButtons) manualButtons.style.display = 'flex';

                } else if (status === 'error') {
                    badge.style.background = '#ffebee';
                    badge.style.color = '#c62828';
                    badge.style.cursor = 'pointer';
                    badge.innerHTML = '<span style="font-size: 1.2em;">⚠️</span> Configurer';
                    badge.onclick = () => window.app.installSharePointLists();
                    if (manualButtons) manualButtons.style.display = 'none'; // Config is priority

                } else if (status === 'saving') {
                    badge.innerHTML = '<span style="font-size: 1.2em;">🔄</span> Enregistrement...';
                }
            },

            // Generic Save Dispatcher
            async save() {
                // Toujours sauvegarder en localStorage (fallback)
                localStorage.setItem(this.storageKey, JSON.stringify(this.data));

                // Sauvegarder aussi dans Firestore si disponible
                if (window.firebaseDb && window.currentUser) {
                    try {
                        const { setDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

                        // Helper to convert ArrayBuffer to Base64
                        const arrayBufferToBase64 = (buffer) => {
                            let binary = '';
                            const bytes = new Uint8Array(buffer);
                            const len = bytes.byteLength;
                            for (let i = 0; i < len; i++) {
                                binary += String.fromCharCode(bytes[i]);
                            }
                            return window.btoa(binary);
                        };

                        // Préparer les participants : RETIRER originalPdf pour Firestore
                        // Nous stockons maintenant pdfData (extrait texte) qui est léger
                        const participantsForSave = (this.data.participants || []).map(p => {
                            const pCopy = { ...p };
                            // Remove heavy PDF binary/base64 data
                            if (pCopy.originalPdf) {
                                delete pCopy.originalPdf;
                            }
                            delete pCopy.isBase64Pdf;
                            return pCopy;
                        });

                        // Sauvegarder les données utilisateur
                        const userDataRef = doc(window.firebaseDb, 'users', window.currentUser.uid);
                        await setDoc(userDataRef, {
                            participants: participantsForSave,
                            classes: this.data.classes || [],
                            attendances: this.data.attendances || [],
                            lastUpdated: new Date().toISOString()
                        });

                        // Sauvegarder les signatures dans une collection partagée
                        if (this.data.signatures && this.data.signatures.length > 0) {
                            const signaturesRef = doc(window.firebaseDb, 'shared', 'signatures');
                            await setDoc(signaturesRef, {
                                signatures: this.data.signatures,
                                lastUpdated: new Date().toISOString()
                            });
                            console.log('✅ Signatures sauvegardées dans Firestore');
                        }

                        console.log('✅ Données sauvegardées dans Firestore');
                    } catch (error) {
                        console.error('❌ Erreur Firestore:', error);
                        // Continue avec localStorage seulement
                    }
                }

                if (this.useSharePointLists) {
                    console.log('ℹ️ List Mode: Global save ignored (Using item-level logic).');
                } else {
                    this.updateStatus('saving');
                    await this.saveToFile();
                    if (!this.useSharePointLists) this.updateStatus('local'); // Revert status
                }
            },

            async saveToFile() {
                if (window.location.protocol === 'file:') {
                    this.showSaveIndicator('⚠️ Mode Local (Backup Auto : OFF)');
                    return;
                }
                try {
                    console.log('☁️ Saving File...');
                    const headers = { 'Accept': 'application/json;odata=verbose', 'Content-Type': 'application/json;odata=verbose' };
                    let digest = '';
                    try {
                        const cr = await fetch(`${this.baseUrl || ''}_api/contextinfo`, { method: 'POST', headers });
                        if (cr.ok) digest = (await cr.json()).d.GetContextWebInformation.FormDigestValue;
                    } catch (e) { }

                    if (digest) {
                        headers['X-RequestDigest'] = digest;
                        const path = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));
                        // Note: For file save we might need robust URL too, but legacy save usually expects current folder
                        // If baseUrl is used, we might need web-relative URL.
                        // Let's stick to simple relative call for Legacy Save as it likely uses current folder
                        const spUrl = `${this.baseUrl || ''}_api/web/getfolderbyserverrelativeurl('${path}')/files/add(url='${this.jsonUrl}', overwrite=true)`;
                        await fetch(spUrl, { method: 'POST', headers, body: JSON.stringify(this.data) });
                        this.showSaveIndicator('✅ Sauvegardé (Web)');
                    } else {
                        await fetch(this.jsonUrl, { method: 'PUT', body: JSON.stringify(this.data) });
                        this.showSaveIndicator('✅ Sauvegardé');
                    }
                } catch (e) {
                    console.error('Save error:', e);
                    this.showSaveIndicator('⚠️ Erreur Sauvegarde');
                }
            },

            showSaveIndicator(text) {
                const btn = document.querySelector('.btn-save-indicator');
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = text;
                    setTimeout(() => btn.textContent = originalText, 4000);
                }
            },

            // CRUD Wrappers
            async getAll(storeName) { return this.data[storeName] || []; },

            async get(storeName, id) {
                const store = this.data[storeName] || [];
                return store.find(item => item.id === id);
            },

            async add(storeName, item) {
                if (!this.data[storeName]) this.data[storeName] = [];
                const index = this.data[storeName].findIndex(i => i.id === item.id);
                if (index !== -1) {
                    this.data[storeName][index] = item;
                } else {
                    this.data[storeName].push(item);
                }

                if (this.useSharePointLists) {
                    await this.spAddOrUpdate(storeName, item);
                } else {
                    await this.save();
                }
                return item.id;
            },

            async update(storeName, item) {
                if (!this.data[storeName]) this.data[storeName] = [];
                const index = this.data[storeName].findIndex(i => i.id === item.id);
                if (index !== -1) {
                    this.data[storeName][index] = item;
                } else {
                    this.data[storeName].push(item);
                }
                await this.save();
                return item.id;
            },

            async delete(storeName, id) {
                if (!this.data[storeName]) return;
                this.data[storeName] = this.data[storeName].filter(i => i.id !== id);

                if (this.useSharePointLists) {
                    // await this.spDelete(storeName, id); // Assuming spDelete exists for SharePoint lists
                } else {
                    await this.save();
                }
            },

            // Adapter Interface Compliance
            async getParticipants() { return this.getAll(STORES.PARTICIPANTS); },
            async saveParticipant(p) { return p.id ? this.update(STORES.PARTICIPANTS, p) : this.add(STORES.PARTICIPANTS, p); },
            async deleteParticipant(id) { return this.delete(STORES.PARTICIPANTS, id); },
            async getClasses() { return this.getAll(STORES.CLASSES); },
            async saveClass(c) { return c.id ? this.update(STORES.CLASSES, c) : this.add(STORES.CLASSES, c); },
            async deleteClass(id) { return this.delete(STORES.CLASSES, id); },
            async getAttendances() { return this.getAll(STORES.ATTENDANCE); },
            async saveAttendances(list) {
                for (const item of list) {
                    await this.update(STORES.ATTENDANCE, item);
                }
            },

            // Archived Participants Support
            async getArchivedParticipants() { return this.getAll('archivedParticipants'); },
            async saveArchivedParticipant(p) {
                if (!this.data.archivedParticipants) this.data.archivedParticipants = [];
                const index = this.data.archivedParticipants.findIndex(i => i.id === p.id);
                if (index !== -1) this.data.archivedParticipants[index] = p;
                else this.data.archivedParticipants.push(p);
                await this.save();
                return p;
            },
            async deleteArchivedParticipant(id) {
                await this.delete('archivedParticipants', id);
            },

            // Signatures Support
            async getSignatures() { return this.getAll('signatures'); },
            async saveSignature(sig) {
                if (!this.data.signatures) this.data.signatures = [];
                const index = this.data.signatures.findIndex(s => s.id === sig.id);
                if (index !== -1) this.data.signatures[index] = sig;
                else this.data.signatures.push(sig);
                await this.save();
                return sig;
            },
            async deleteSignature(id) {
                if (!this.data.signatures) return;
                this.data.signatures = this.data.signatures.filter(s => s.id !== id);
                await this.save();
            }
        };

        // Initialize default dbService
        var dbService = jsonDbService;
        window.dbService = dbService;

        // --- INSTALLER LOGIC (External) ---
        window.app.installSharePointLists = async function () {
            if (!confirm('Voulez-vous installer les bases de données SharePoint (Listes) maintenant ?\n\nNécessaire pour le mode multi-utilisateurs.')) return;

            const lists = ['MMT_Participants', 'MMT_Classes', 'MMT_Attendance'];
            let log = '';

            try {
                // Use detected URL or try current Relative
                let baseUrl = dbService.baseUrl;
                if (baseUrl === undefined) baseUrl = '';

                const r = await fetch(`${baseUrl}_api/contextinfo`, { method: 'POST', headers: { 'Accept': 'application/json;odata=verbose' } });
                const digest = (await r.json()).d.GetContextWebInformation.FormDigestValue;

                for (const title of lists) {
                    try {
                        console.log(`Creating ${title}...`);
                        await fetch(`${baseUrl}_api/web/lists`, {
                            method: 'POST',
                            headers: {
                                'Accept': 'application/json;odata=verbose',
                                'Content-Type': 'application/json;odata=verbose',
                                'X-RequestDigest': digest
                            },
                            body: JSON.stringify({
                                '__metadata': { 'type': 'SP.List' },
                                'AllowContentTypes': true,
                                'BaseTemplate': 100, // Generic List
                                'ContentTypesEnabled': true,
                                'Description': 'Database for MMT App',
                                'Title': title
                            })
                        });

                        await fetch(`${baseUrl}_api/web/lists/getbytitle('${title}')/fields`, {
                            method: 'POST',
                            headers: {
                                'Accept': 'application/json;odata=verbose',
                                'Content-Type': 'application/json;odata=verbose',
                                'X-RequestDigest': digest
                            },
                            body: JSON.stringify({
                                '__metadata': { 'type': 'SP.Field' },
                                'Title': 'JSON_Data',
                                'FieldTypeKind': 3, // Memo/Note
                                'Required': false,
                                'EnforceUniqueValues': false,
                                'StaticName': 'JSON_Data'
                            })
                        });

                        log += `✅ Liste ${title} créée.\n`;
                    } catch (e) {
                        log += `⚠️ Liste ${title} existe déjà ou erreur.\n`;
                    }
                }
                alert('Installation terminée !\n\n' + log + '\nRechargez la page.');
                location.reload();
            } catch (e) {
                alert('Erreur: Impossible de contacter SharePoint.\n' + e.message + '\n\nVérifiez que le fichier est bien sur le site SharePoint.');
            }
        };

        // Participant Service
        const participantService = {
            async getAllParticipants() {
                if (dbService.getParticipants) return await dbService.getParticipants();
                return await dbService.getAll(STORES.PARTICIPANTS);
            },

            async addParticipant(participant) {
                if (!participant.id) participant.id = crypto.randomUUID();
                if (dbService.saveParticipant) return await dbService.saveParticipant(participant);
                return await dbService.add(STORES.PARTICIPANTS, participant);
            },

            async updateParticipant(participant) {
                if (arguments.length === 2) {
                    const data = arguments[1];
                    data.id = arguments[0];
                    participant = data;
                }
                if (dbService.saveParticipant) return await dbService.saveParticipant(participant);
                return await dbService.update(STORES.PARTICIPANTS, participant);
            },

            async deleteParticipant(id) {
                if (dbService.deleteParticipant) return await dbService.deleteParticipant(id);
                return await dbService.delete(STORES.PARTICIPANTS, id);
            }
        };

        // Class Service
        const classService = {
            async getAllClasses() {
                if (dbService.getClasses) return await dbService.getClasses();
                return await dbService.getAll(STORES.CLASSES);
            },

            async addClass(cls) {
                if (!cls.id) cls.id = crypto.randomUUID();
                if (dbService.saveClass) return await dbService.saveClass(cls);
                return await dbService.add(STORES.CLASSES, cls);
            },

            async updateClass(cls) {
                if (dbService.saveClass) return await dbService.saveClass(cls);
                return await dbService.update(STORES.CLASSES, cls);
            },

            async deleteClass(id) {
                if (dbService.deleteClass) return await dbService.deleteClass(id);
                return await dbService.delete(STORES.CLASSES, id);
            },

            async addParticipantToClass(classId, participantId) {
                const cls = await this.getClass(classId);
                if (!cls.participantIds) cls.participantIds = [];
                if (!cls.participantIds.includes(participantId)) {
                    cls.participantIds.push(participantId);
                    await this.updateClass(cls);
                }
            },

            async getClass(id) {
                if (dbService.getClasses) {
                    const classes = await dbService.getClasses();
                    return classes.find(c => c.id === id);
                }
                return await dbService.get(STORES.CLASSES, id);
            }
        };

        // Initialize window.app namespace immediately
        window.app = window.app || {};


        // Initialize App
        // Initialize App
        document.addEventListener('DOMContentLoaded', async () => {
            // DECISION: Use Firebase if available (via adapter), else JSON
            if (window.firebaseStorage) {
                console.log('🔥 Using Firebase Storage Adapter as primary DB');
                dbService = window.firebaseStorage; // Update local scope var
                window.dbService = window.firebaseStorage;

                if (window.dbService.init) {
                    await window.dbService.init().catch(err => console.error('Firebase Init Error:', err));
                }
                initApp();
            } else {
                console.warn('⚠️ No Firebase Adapter found. Falling back to local JSON/SharePoint mode.');
                dbService = jsonDbService;
                window.dbService = jsonDbService;

                dbService.init().then(() => {
                    initApp();
                }).catch(err => {
                    console.error('Database initialization failed', err);
                    alert('Erreur: Impossible d\'initialiser la base de données.');
                });
            }
        });

        function initApp() {
            setupNavigation();

            // Setup dashboard month change listener
            const monthInput = document.getElementById('dashboard-month');
            if (monthInput) {
                monthInput.addEventListener('change', () => renderDashboard());
            }

            // Setup month navigation buttons
            const btnPrev = document.getElementById('btn-prev-month');
            const btnNext = document.getElementById('btn-next-month');

            if (btnPrev && btnNext && monthInput) {
                const changeMonth = (delta) => {
                    if (!monthInput.value) return;
                    const [year, month] = monthInput.value.split('-').map(Number);
                    const date = new Date(year, month - 1 + delta, 1);
                    const newYear = date.getFullYear();
                    const newMonth = String(date.getMonth() + 1).padStart(2, '0');
                    monthInput.value = `${newYear}-${newMonth}`;
                    renderDashboard();
                };

                btnPrev.addEventListener('click', () => changeMonth(-1));
                btnNext.addEventListener('click', () => changeMonth(1));
            }

            // Update active nav link
            updateActiveNavLink('dashboard');

            // Render initial dashboard
            renderDashboard();
        }

        function setupNavigation() {
            const navLinks = document.querySelectorAll('.nav-link');
            navLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = e.target.getAttribute('href').substring(1);
                    navigateTo(targetId);
                });
            });

            // Tab Switching Logic
            const tabBtns = document.querySelectorAll('.tab-btn');
            tabBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    tabBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');
                    const tabId = btn.getAttribute('data-tab');
                    document.getElementById(`tab-${tabId}`).style.display = 'block';
                });
            });

            // Class Details Back Button
            const btnBackClasses = document.getElementById('btn-back-classes');
            if (btnBackClasses) {
                btnBackClasses.addEventListener('click', () => {
                    navigateTo('classes');
                });
            }

            // Attendance Date Navigation
            const dateInput = document.getElementById('attendance-date');
            const btnPrevDate = document.getElementById('btn-prev-date');
            const btnNextDate = document.getElementById('btn-next-date');

            if (dateInput && btnPrevDate && btnNextDate) {
                dateInput.addEventListener('change', () => {
                    if (currentClassId) {
                        // Determine which class object to pass. loadAttendanceGrid expects the Class Object, not ID.
                        // We need to fetch it. But loadAttendanceGrid is async and we need to wait.
                        // Or better, just reload the grid.
                        // Quick fix: re-call loadClassDetails or duplicate logic.
                        // Actually, loadClassDetails sets up everything.
                        // Let's just refactor loadAttendanceGrid to take ID? 
                        // Or better, fetch class then load.
                        refreshAttendanceGrid();
                    }
                });

                const changeDate = (days) => {
                    if (!dateInput.value) dateInput.valueAsDate = new Date();
                    const date = new Date(dateInput.value);
                    date.setDate(date.getDate() + days);
                    dateInput.valueAsDate = date;
                    refreshAttendanceGrid();
                };

                // These are now handled by onclick in HTML
                // btnPrevDate.addEventListener('click', () => changeDate(-1));
                // btnNextDate.addEventListener('click', () => changeDate(1));
            }
        }

        async function refreshAttendanceGrid() {
            if (!currentClassId) return;
            try {
                const classes = await classService.getAllClasses();
                const cls = classes.find(c => c.id === currentClassId);
                if (cls) loadAttendanceGrid(cls);
            } catch (e) { console.error(e); }
        }

        function navigateTo(viewId) {
            // Hide all views
            document.querySelectorAll('.view-section').forEach(el => el.style.display = 'none');
            // Show target view
            const targetView = document.getElementById(viewId);
            if (targetView) {
                targetView.style.display = 'block';
                updateActiveNavLink(viewId);

                if (viewId === 'participants') {
                    loadParticipantsView();
                } else if (viewId === 'classes') {
                    if (window.app.loadClasses) {
                        window.app.loadClasses();
                    }
                } else if (viewId === 'dashboard') {
                    renderDashboard();
                }
            }
        }

        function updateActiveNavLink(viewId) {
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${viewId}`) {
                    link.classList.add('active');
                }
            });
        }

        // --- Dashboard Logic ---
        async function renderDashboard() {
            const monthInput = document.getElementById('dashboard-month');
            if (!monthInput) {
                console.error('❌ ERREUR: La section dashboard est manquante dans index.html');
                const container = document.getElementById('dashboard-content');
                if (container) {
                    container.innerHTML = '<p class="error">Erreur: Section dashboard manquante. Veuillez restaurer le fichier index.html.</p>';
                }
                return;
            }

            if (!monthInput.value) {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                monthInput.value = `${year}-${month}`;
            }
            const monthValue = monthInput.value;

            if (!monthValue) return;

            const [year, month] = monthValue.split('-');
            const daysInMonth = new Date(year, month, 0).getDate();

            const container = document.getElementById('dashboard-content');
            container.innerHTML = '<p>Chargement...</p>';

            try {
                // Fetch all data (Active + Archived)
                // Fetch all data (Active + Archived)
                let rawParticipants = await participantService.getAllParticipants();

                // Handle archived fetching via Adapter or direct property
                let archived = [];
                if (dbService.getArchivedParticipants) {
                    archived = await dbService.getArchivedParticipants();
                } else if (dbService.getAll) {
                    archived = await dbService.getAll('archivedParticipants');
                } else if (dbService.data && dbService.data.archivedParticipants) {
                    archived = dbService.data.archivedParticipants;
                }

                if (archived && archived.length > 0) {
                    const activeIds = new Set(rawParticipants.map(p => p.id));
                    const uniqueArchived = archived.filter(p => !activeIds.has(p.id));
                    rawParticipants = [...rawParticipants, ...uniqueArchived];
                }

                // Filter by Date Overlap with current View Month
                const [vYear, vMonth] = monthValue.split('-').map(Number);
                const viewStart = new Date(vYear, vMonth - 1, 1);
                const viewEnd = new Date(vYear, vMonth, 0);
                viewEnd.setHours(23, 59, 59, 999);

                const participants = rawParticipants.filter(p => {
                    if (!p.dateStart) return true; // Show if no start (legacy)
                    const pStart = new Date(p.dateStart);
                    if (isNaN(pStart.getTime())) return true;

                    // If starts after end of view, hide
                    if (pStart > viewEnd) return false;

                    if (p.dateEnd) {
                        const pEnd = new Date(p.dateEnd);
                        // If ends before start of view, hide
                        if (!isNaN(pEnd.getTime()) && pEnd < viewStart) return false;
                    }
                    return true;
                });

                // Récupérer les présences via la méthode appropriée
                let allAttendance = [];
                if (dbService.getAttendances) {
                    allAttendance = await dbService.getAttendances();
                } else if (dbService.getAll) {
                    allAttendance = await dbService.getAll(STORES.ATTENDANCE);
                }

                // Filter attendance for this month
                const monthAtt = allAttendance.filter(r => r.date && r.date.startsWith(monthValue));

                if (participants.length === 0) {
                    container.innerHTML = `
                <div style="text-align: center; padding: 2rem; color: #666;">
                    <p>Aucun participant trouvé.</p>
                </div>`;
                    return;
                }

                // Sort participants alphabetically
                participants.sort((a, b) => a.lastName.localeCompare(b.lastName));

                // Group participants by class
                const classes = await classService.getAllClasses();
                const participantsByClass = {};

                // First, add participants that belong to classes
                classes.forEach(cls => {
                    if (cls.participantIds && cls.participantIds.length > 0) {
                        participantsByClass[cls.name] = participants.filter(p => cls.participantIds.includes(p.id));
                    }
                });

                // Then add participants without class
                const participantsWithClass = Object.values(participantsByClass).flat();
                const participantsWithoutClass = participants.filter(p => !participantsWithClass.find(pc => pc.id === p.id));
                if (participantsWithoutClass.length > 0) {
                    participantsByClass['Sans classe'] = participantsWithoutClass;
                }

                // Format date helper - DD.MM.YYYY
                const formatDate = (isoDate) => {
                    if (!isoDate) return '-';
                    const [y, m, d] = isoDate.split('-');
                    return `${d}.${m}.${y}`;
                };

                let tableHtml = `
            <style>
                .calendar-container {
                    border-radius: 12px;
                    overflow: hidden;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    background: white;
                    margin-bottom: 2rem;
                }
                .calendar-table {
                    width: 100%;
                    border-collapse: collapse;
                }
                .calendar-table th {
                    background: var(--primary);
                    color: white;
                    padding: 0.5rem 0.3rem;
                    font-weight: 600;
                    font-size: 0.75rem;
                    text-align: center;
                    white-space: nowrap;
                }
                .calendar-table th.class-name-header {
                    background: var(--primary);
                    color: white;
                    font-size: 1rem;
                    padding: 0.75rem;
                    text-align: left;
                    font-weight: 700;
                }
                .calendar-table td {
                    font-size: 0.75rem;
                    padding: 0.3rem;
                }
                .period-col {
                    font-weight: 700;
                    color: var(--primary);
                    font-size: 0.75rem;
                    text-align: center;
                }
                .code-g-tooltip {
                    position: relative;
                    cursor: help;
                }
                .code-g-tooltip:hover::after {
                    content: attr(data-comment);
                    position: absolute;
                    bottom: 100%;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #333;
                    color: white;
                    padding: 0.5rem;
                    border-radius: 6px;
                    white-space: nowrap;
                    max-width: 300px;
                    font-size: 0.75rem;
                    z-index: 1000;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                }
            </style>
        `;

                // Rows for each class group
                for (const [className, classParticipants] of Object.entries(participantsByClass)) {
                    const cls = classes.find(c => c.name === className);
                    const classId = cls ? cls.id : null;
                    const manageBtn = (classId && className !== 'Sans classe')
                        ? `<button onclick="window.app.openClassAttendance('${classId}')" class="btn-secondary btn-sm" style="background:rgba(255,255,255,0.2); color:white; border:1px solid rgba(255,255,255,0.4); margin-left:1rem; padding:0.2rem 0.6rem; font-size:0.8rem;">⚙️ Gérer les présences</button>`
                        : '';

                    tableHtml += `
            <div class="calendar-container">
                <table class="calendar-table">
                    <thead>
                        <tr>
                            <th class="class-name-header" colspan="${5 + daysInMonth}">
                                <div style="display:flex; justify-content:space-between; align-items:center;">
                                    <span>${className}</span>
                                    ${manageBtn}
                                </div>
                            </th>
                        </tr>
                        <tr>
                            <th style="min-width: 120px; text-align: left; padding-left: 0.75rem;">Participant</th>
                            <th style="min-width: 70px;">Début</th>
                            <th style="min-width: 70px;">Fin</th>
                            <th style="min-width: 50px;">Total H</th>
                            <th style="min-width: 30px;"></th>
        `;

                    // Header Days
                    for (let d = 1; d <= daysInMonth; d++) {
                        tableHtml += `<th style="min-width: 25px;">${d}</th>`;
                    }
                    tableHtml += `</tr></thead><tbody>`;

                    // Participants in this class
                    classParticipants.forEach(p => {
                        // Calculate total hours
                        let totalHours = 0;
                        for (let d = 1; d <= daysInMonth; d++) {
                            const dateStr = `${monthValue}-${String(d).padStart(2, '0')}`;
                            const record = monthAtt.find(r => r.participantId === p.id && r.date === dateStr);
                            const mCode = record ? (record.morningCode === 'P' ? 'X' : record.morningCode) : '';
                            const aCode = record ? (record.afternoonCode === 'P' ? 'X' : record.afternoonCode) : '';

                            // Count 'X' (Sur place) as 4h AM / 2h PM
                            if (mCode === 'X') totalHours += 4;
                            if (aCode === 'X') totalHours += 2;
                        }

                        let rowMatin = `<td class="name-col" rowspan="2" style="border-bottom: 2px solid #e0e0e0; position:relative;">
                                    <div>${p.firstName} ${p.lastName}</div>
                                    <button class="btn-sm btn-secondary" style="margin-top:0.2rem; font-size:0.75rem; padding:0.1rem 0.4rem;" onclick="window.app.exportParticipantPDF('${p.id}')" title="Imprimer ce MMT">🖨️ PDF</button>
                                </td>
                                <td rowspan="2" style="border-bottom: 2px solid #e0e0e0;">${formatDate(p.dateStart)}</td>
                                <td rowspan="2" style="border-bottom: 2px solid #e0e0e0;">${formatDate(p.dateEnd)}</td>
                                <td rowspan="2" style="font-weight:bold; text-align:center; border-bottom: 2px solid #e0e0e0;">${totalHours}h</td>
                                <td class="period-col">M</td>`;
                        let rowAprem = `<td class="period-col" style="border-bottom: 2px solid #e0e0e0;">AM</td>`;

                        // Cells
                        for (let d = 1; d <= daysInMonth; d++) {
                            const dateStr = `${monthValue}-${String(d).padStart(2, '0')}`;
                            // Use UTC day to align with YYYY-MM-DD parsing
                            const dayOfWeek = new Date(dateStr).getUTCDay();
                            const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                            const weekendClass = isWeekend ? 'weekend' : '';

                            // Check schedule
                            let isScheduledAm = true;
                            let isScheduledPm = true;

                            if (!isWeekend && p.schedule) {
                                isScheduledAm = p.schedule[`${dayOfWeek}-am`];
                                isScheduledPm = p.schedule[`${dayOfWeek}-pm`];
                            }

                            const record = monthAtt.find(r => r.participantId === p.id && r.date === dateStr);

                            const mCode = record ? (record.morningCode === 'P' ? 'X' : record.morningCode) : '';
                            const aCode = record ? (record.afternoonCode === 'P' ? 'X' : record.afternoonCode) : '';
                            const comment = record ? record.comment : '';

                            const getCellClass = (code, isScheduled) => {
                                if (!isScheduled && !code) return 'cell-disabled';
                                if (code === 'X' || code === 'O') return 'cell-x';
                                if (code === '?') return 'cell-unknown';
                                if (code && code !== '') return 'cell-other';
                                return '';
                            };

                            // Add tooltip for code G
                            const tooltipClass = (mCode === 'G' && comment) ? 'code-g-tooltip' : '';
                            const tooltipAttr = (mCode === 'G' && comment) ? `data-comment="${comment}"` : '';

                            // Interruption Logic
                            let cellContentM = mCode || '';
                            let cellContentA = aCode || '';

                            // Check if this is the last day of course
                            const isLastDay = p.dateEnd && dateStr === p.dateEnd;
                            const lastDayStyle = isLastDay ? 'background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); border: 2px solid #ff9800; font-weight: bold;' : '';
                            const lastDayTooltip = isLastDay ? 'title="🎓 Fin de cours"' : '';

                            if (p.interruptionMMT && p.interruptionDate === dateStr) {
                                const interruptionIcon = '<span title="Interruption de la MMT" style="cursor:help; font-size:1.2em;">😢</span>';
                                cellContentM += interruptionIcon;
                                cellContentA += interruptionIcon;
                            }

                            // Add onclick for editable cells - ALWAYS allow editing even if not scheduled (User Request)
                            const onclickM = `onclick="window.app.editDashboardCell('${p.id}', '${dateStr}', 'morning', '${mCode}', '${comment.replace(/'/g, "\\'")}', '${className}')"`;
                            const onclickA = `onclick="window.app.editDashboardCell('${p.id}', '${dateStr}', 'afternoon', '${aCode}', '${comment.replace(/'/g, "\\'")}', '${className}')"`;
                            const cursorStyle = 'cursor: pointer;';

                            rowMatin += `<td class="${weekendClass} ${getCellClass(mCode, isScheduledAm)} ${tooltipClass}" ${tooltipAttr} style="${lastDayStyle} ${cursorStyle}" ${lastDayTooltip} ${onclickM}>${cellContentM}</td>`;

                            const tooltipClassAm = (aCode === 'G' && comment) ? 'code-g-tooltip' : '';
                            const tooltipAttrAm = (aCode === 'G' && comment) ? `data-comment="${comment}"` : '';
                            rowAprem += `<td class="${weekendClass} ${getCellClass(aCode, isScheduledPm)} ${tooltipClassAm}" ${tooltipAttrAm} style="border-bottom: 2px solid #e0e0e0; ${lastDayStyle} ${cursorStyle}" ${lastDayTooltip} ${onclickA}>${cellContentA}</td>`;
                        }

                        tableHtml += `<tr>${rowMatin}</tr><tr>${rowAprem}</tr>`;
                    });

                    tableHtml += `</tbody></table></div>`;
                }

                container.innerHTML = tableHtml;

            } catch (error) {
                console.error('Error rendering dashboard', error);
                container.innerHTML = '<p class="error">Erreur lors du chargement du tableau de bord.</p>';
            }
        }

        // --- Participants View ---

        // Helper function to format dates
        function formatDate(isoDate) {
            if (!isoDate) return '';
            const [year, month, day] = isoDate.split('-');
            return `${day}.${month}.${year}`;
        }

        async function loadParticipantsView() {
            await loadActiveParticipants();
            await loadArchivedParticipants();
        }

        async function loadActiveParticipants() {
            const listContainer = document.getElementById('participants-list');
            if (!listContainer) return;

            listContainer.innerHTML = '<p>Chargement...</p>';
            try {
                const participants = await participantService.getAllParticipants();
                if (participants.length === 0) {
                    listContainer.innerHTML = '<p>Aucun participant actif. Importez un PDF ou créez-en un manuellement.</p>';
                } else {
                    // Sort by Last Name
                    participants.sort((a, b) => a.lastName.localeCompare(b.lastName));

                    listContainer.innerHTML = participants.map(p => {
                        // Format schedule display
                        let scheduleHtml = '';
                        const workPercent = parseInt(p.workPercent || 100);

                        if (p.schedule && workPercent < 100) {
                            const days = ['Lun', 'Mar', 'Mer', 'Jeu', 'Ven'];
                            scheduleHtml = '<div style="margin-top: 0.5rem;">';
                            days.forEach((d, i) => {
                                const dayKey = i + 1;
                                const am = p.schedule[`${dayKey}-am`];
                                const pm = p.schedule[`${dayKey}-pm`];
                                if (am || pm) {
                                    scheduleHtml += `<span class="schedule-badge active">${d}: ${am ? 'M' : ''}${am && pm ? '+' : ''}${pm ? 'AM' : ''}</span>`;
                                }
                            });
                            scheduleHtml += '</div>';
                        }

                        return `
                <div class="participant-card" style="position: relative;">
                    <div style="position: absolute; top: 10px; left: 10px;">
                        <input type="checkbox" class="participant-batch-cb" value="${p.id}" style="transform: scale(1.5);">
                    </div>
                    <h3 style="margin-left: 25px;">${p.firstName} ${p.lastName}</h3>
                    <div class="card-details" style="margin-left: 25px;">
                        <p>Travail: <strong>${p.workPercent || 100}%</strong></p>
                        ${p.dateStart ? `<p>Début: <strong>${formatDate(p.dateStart)}</strong></p>` : ''}
                        ${p.dateEnd ? `<p>Fin: <strong>${formatDate(p.dateEnd)}</strong></p>` : ''}
                        ${p.courseType ? `<p>Cours: <strong>${p.courseType}</strong></p>` : ''}
                        ${scheduleHtml}
                    </div>
                    <div class="card-actions" style="margin-top: 1rem; display: flex; gap: 0.5rem; margin-left: 25px;">
                        <button class="btn-secondary btn-sm" onclick="window.app.editParticipant('${p.id}')">✏️ Modifier</button>
                        <button class="btn-secondary btn-sm" onclick="window.app.exportParticipantPDF('${p.id}')" title="Exporter PDF">📄 PDF</button>
                        <button class="btn-secondary btn-sm" onclick="window.app.deleteParticipant('${p.id}')" style="color: var(--primary);" title="Supprimer">🗑️</button>
                    </div>
                </div>
            `;
                    }).join('');
                }
            } catch (error) {
                console.error('Error loading participants', error);
                listContainer.innerHTML = '<p class="error">Erreur lors du chargement des participants.</p>';
            }
        }

        async function loadArchivedParticipants() {
            const listContainer = document.getElementById('archived-participants-list');
            if (!listContainer) return;

            listContainer.innerHTML = '<p>Chargement...</p>';
            try {
                let archived = [];
                if (dbService.getArchivedParticipants) {
                    archived = await dbService.getArchivedParticipants();
                } else if (dbService.getAll) {
                    archived = await dbService.getAll('archivedParticipants');
                } else {
                    // Fallback for direct data access if adapter mimics data structure
                    archived = (dbService.data && dbService.data.archivedParticipants) ? dbService.data.archivedParticipants : [];
                }
                if (archived.length === 0) {
                    listContainer.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Aucun participant archivé.</p>';
                } else {
                    archived.sort((a, b) => a.lastName.localeCompare(b.lastName));

                    listContainer.innerHTML = archived.map(p => {
                        return `
                <div class="participant-card" style="opacity: 0.7; background: #f5f5f5; position: relative;">
                    <div style="position: absolute; top: 10px; left: 10px;">
                        <input type="checkbox" class="archived-batch-cb" value="${p.id}" style="transform: scale(1.5);">
                    </div>
                    <h3 style="margin-left: 25px;">${p.firstName} ${p.lastName}</h3>
                    <div class="card-details" style="margin-left: 25px;">
                        <p>Travail: <strong>${p.workPercent || 100}%</strong></p>
                        ${p.dateStart ? `<p>Début: <strong>${formatDate(p.dateStart)}</strong></p>` : ''}
                        ${p.dateEnd ? `<p>Fin: <strong style="color: #d32f2f;">${formatDate(p.dateEnd)}</strong> ✅ Terminé</p>` : ''}
                        ${p.courseType ? `<p>Cours: <strong>${p.courseType}</strong></p>` : ''}
                    </div>
                    <div class="card-actions" style="margin-top: 1rem; display: flex; gap: 0.5rem; margin-left: 25px;">
                        <button class="btn-secondary btn-sm" onclick="window.app.restoreParticipant('${p.id}')">↺ Réactiver</button>
                        <button class="btn-secondary btn-sm" onclick="window.app.exportParticipantPDF('${p.id}')" title="Exporter PDF">📄 PDF</button>
                        <button class="btn-secondary btn-sm" onclick="window.app.deleteArchivedParticipant('${p.id}')" style="color: var(--primary);" title="Supprimer définitivement">🗑️</button>
                    </div>
                </div>
            `;
                    }).join('');
                }
            } catch (error) {
                console.error('Error loading archived participants', error);
                listContainer.innerHTML = '<p class="error">Erreur lors du chargement des archives.</p>';
            }
        }

        window.app.toggleSelectAllParticipants = (source) => {
            const checkboxes = document.querySelectorAll('.participant-batch-cb');
            checkboxes.forEach(cb => cb.checked = source.checked);
        };

        window.app.deleteSelectedParticipants = async () => {
            const checkboxes = document.querySelectorAll('.participant-batch-cb:checked');
            const ids = Array.from(checkboxes).map(cb => cb.value);

            if (ids.length === 0) {
                alert('Veuillez sélectionner au moins un participant à supprimer.');
                return;
            }

            if (!confirm(`Êtes-vous sûr de vouloir supprimer ${ids.length} participant(s) ?`)) return;

            try {
                for (const id of ids) {
                    await participantService.deleteParticipant(id);
                }

                // Clean from classes
                const allClasses = await classService.getAllClasses();
                for (const c of allClasses) {
                    if (c.participantIds) {
                        const originalLen = c.participantIds.length;
                        c.participantIds = c.participantIds.filter(pid => !ids.includes(pid));
                        if (c.participantIds.length !== originalLen) {
                            await classService.updateClass(c);
                        }
                    }
                }

                // Reset select all checkbox
                const selectAllCb = document.getElementById('cb-select-all-participants');
                if (selectAllCb) selectAllCb.checked = false;

                loadParticipantsView();
                alert(`${ids.length} participant(s) supprimé(s).`);
            } catch (error) {
                console.error('Error deleting participants batch', error);
                alert('Erreur lors de la suppression par lot.');
            }
        };

        // Participant Modal Logic

        window.app.openNewParticipantModal = () => {
            document.getElementById('form-participant').reset();
            document.getElementById('p-id').value = '';
            document.getElementById('modal-p-title').textContent = 'Nouveau Participant';
            document.getElementById('modal-participant').style.display = 'flex';
        };

        window.app.closeModal = (id) => {
            document.getElementById(id).style.display = 'none';
        };

        window.app.editParticipant = async (id) => {
            try {
                const participants = await participantService.getAllParticipants();
                const p = participants.find(x => x.id === id);
                if (!p) return;

                document.getElementById('modal-p-title').textContent = 'Modifier Participant';
                document.getElementById('p-id').value = p.id;
                document.getElementById('p-firstname').value = p.firstName;
                document.getElementById('p-lastname').value = p.lastName;
                document.getElementById('p-work-percent').value = p.workPercent || 100;
                document.getElementById('p-date-start').value = p.dateStart || '';
                document.getElementById('p-date-end').value = p.dateEnd || '';
                document.getElementById('p-interruption-mmt').checked = p.interruptionMMT || false;
                document.getElementById('p-interruption-date').value = p.interruptionDate || '';
                document.getElementById('p-interruption-reason').value = p.interruptionReason || '';

                // Set schedule checkboxes
                for (let i = 1; i <= 5; i++) {
                    const am = p.schedule ? p.schedule[`${i}-am`] : true; // Default true
                    const pm = p.schedule ? p.schedule[`${i}-pm`] : true;
                    const amCb = document.querySelector(`input[name="sched-${i}-am"]`);
                    const pmCb = document.querySelector(`input[name="sched-${i}-pm"]`);
                    if (amCb) amCb.checked = am;
                    if (pmCb) pmCb.checked = pm;
                }

                document.getElementById('modal-participant').style.display = 'flex';
            } catch (error) {
                console.error('Error editing participant', error);
            }
        };

        window.app.handleParticipantSubmit = async (event) => {
            event.preventDefault();
            const id = document.getElementById('p-id').value;
            const firstName = document.getElementById('p-firstname').value;
            const lastName = document.getElementById('p-lastname').value;
            const workPercent = document.getElementById('p-work-percent').value;
            const dateStart = document.getElementById('p-date-start').value;
            const dateEnd = document.getElementById('p-date-end').value;
            const interruptionMMT = document.getElementById('p-interruption-mmt').checked;
            const interruptionDate = document.getElementById('p-interruption-date').value;
            const interruptionReason = document.getElementById('p-interruption-reason').value;

            // Capture schedule
            const schedule = {};
            for (let i = 1; i <= 5; i++) {
                const amCb = document.querySelector(`input[name="sched-${i}-am"]`);
                const pmCb = document.querySelector(`input[name="sched-${i}-pm"]`);
                schedule[`${i}-am`] = amCb ? amCb.checked : false;
                schedule[`${i}-pm`] = pmCb ? pmCb.checked : false;
            }

            try {
                const participantData = {
                    firstName,
                    lastName,
                    workPercent,
                    dateStart,
                    dateEnd,
                    interruptionMMT,
                    interruptionDate,
                    interruptionReason,
                    schedule
                };

                if (id) {
                    // Fetch existing participant to preserve originalPdf and other fields
                    const existing = (await participantService.getAllParticipants()).find(p => p.id === id);
                    if (existing) {
                        // Merge existing data with new data
                        const updatedParticipant = { ...existing, ...participantData, id };
                        await participantService.updateParticipant(updatedParticipant);
                    } else {
                        // Fallback if not found (should not happen)
                        participantData.id = id;
                        await participantService.updateParticipant(participantData);
                    }
                } else {
                    await participantService.addParticipant(participantData);
                }

                document.getElementById('modal-participant').style.display = 'none';
                event.target.reset();
                loadParticipantsView(); // Refresh list
                if (document.getElementById('dashboard').style.display !== 'none') {
                    renderDashboard();
                }
            } catch (error) {

                console.error('Error saving participant', error);
                alert('Erreur lors de l\'enregistrement du participant');
            }
        };

        // PDF Import Logic
        window.app.handlePDFSelection = (e) => {
            const files = Array.from(e.target.files);
            const importPreview = document.getElementById('import-preview');
            if (files.length > 0) {
                importPreview.innerHTML = `
                    <p><strong>${files.length} fichier(s) sélectionné(s) :</strong></p>
                    <ul style="margin-left: 1.5rem;">
                        ${files.map(f => `<li>${f.name}</li>`).join('')}
                    </ul>
                `;
            } else {
                importPreview.innerHTML = '';
            }
        };

        window.app.handlePDFImport = async (e) => {
            e.preventDefault();
            console.log('🚀 handlePDFImport CALLED');

            const pdfFileInput = document.getElementById('pdf-file');
            const importPreview = document.getElementById('import-preview');
            const files = Array.from(pdfFileInput.files);

            if (files.length === 0) {
                alert('Veuillez sélectionner au moins un fichier PDF.');
                return;
            }

            let successCount = 0;
            let errorCount = 0;
            const errors = [];

            const btn = e.target.querySelector('button[type="submit"]');
            const originalBtnText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Traitement...';

            // Show Progress Bar
            window.app.showProgress('Analyse et importation des PDFs...');
            let processedCount = 0;

            for (const file of files) {
                // Update Progress
                processedCount++;
                window.app.updateProgress(processedCount, files.length, `Traitement de ${file.name}...`);

                try {
                    console.log(`Processing: ${file.name}`);
                    const data = await parsePDF(file);
                    data.originalPdf = await file.arrayBuffer();

                    // Save first PDF as global template if none exists
                    if (!cachedTemplate && data.originalPdf) {
                        cachedTemplate = data.originalPdf;
                        await saveTemplateToStorage(data.originalPdf);
                        console.log('✅ Premier PDF importé défini comme template global');
                    }

                    const allParticipants = await participantService.getAllParticipants();
                    const exists = allParticipants.find(p => {
                        const lastNameMatch = p.lastName.toLowerCase() === data.lastName.toLowerCase();
                        const firstNameMatch = (!p.firstName && !data.firstName) ||
                            (p.firstName && data.firstName &&
                                p.firstName.toLowerCase() === data.firstName.toLowerCase());
                        return lastNameMatch && firstNameMatch;
                    });

                    if (exists) {
                        await participantService.updateParticipant(exists.id, data);
                    } else {
                        await participantService.addParticipant(data);
                    }

                    // Création automatique de la classe et ajout du participant
                    if (data.courseType) {
                        const allClasses = await classService.getAllClasses();
                        let targetClass = allClasses.find(c => c.name === data.courseType);

                        const participantId = exists ? exists.id : data.id;

                        if (!targetClass) {
                            // Créer la classe si elle n'existe pas
                            const newClass = {
                                name: data.courseType,
                                participantIds: [participantId],
                                createdAt: new Date().toISOString()
                            };
                            await classService.addClass(newClass);
                            console.log(`✅ Classe créée automatiquement: ${data.courseType}`);
                        } else {
                            // Ajouter le participant à la classe existante s'il n'y est pas déjà
                            if (!targetClass.participantIds) {
                                targetClass.participantIds = [];
                            }
                            if (!targetClass.participantIds.includes(participantId)) {
                                targetClass.participantIds.push(participantId);
                                await classService.updateClass(targetClass);
                                console.log(`✅ Participant ajouté à la classe: ${data.courseType}`);
                            }
                        }
                    }

                    successCount++;
                } catch (error) {
                    console.error(`❌ Error processing ${file.name}:`, error);
                    errorCount++;
                    errors.push(`${file.name}: ${error.message}`);
                }
            }



            // Hide Progress
            window.app.hideProgress();

            btn.disabled = false;
            btn.textContent = originalBtnText;

            window.app.closeModal('modal-pdf-import');
            e.target.reset();
            importPreview.innerHTML = '';

            if (successCount > 0) {
                loadParticipantsView();
                const dashboardEl = document.getElementById('dashboard');
                if (dashboardEl && dashboardEl.style.display !== 'none') {
                    renderDashboard();
                }
            }

            if (errorCount > 0) {
                let message = `Import terminé avec des erreurs:\n❌ ${errorCount} erreur(s)`;
                if (errors.length > 0) message += `\n\nDétails:\n${errors.join('\n')}`;
                alert(message);
            } else {
                console.log(`✅ Import terminé: ${successCount} réussi(s)`);
            }
        };

        // PDF Export Logic
        // Global template management with IndexedDB (better for large files)
        const TEMPLATE_DB_NAME = 'MMT_Templates_DB';
        const TEMPLATE_STORE_NAME = 'pdf_templates';
        const TEMPLATE_KEY = 'pdf_template';

        let cachedTemplate = null;

        // Initialize IndexedDB
        function openTemplateDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(TEMPLATE_DB_NAME, 1);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(TEMPLATE_STORE_NAME)) {
                        db.createObjectStore(TEMPLATE_STORE_NAME);
                    }
                };
            });
        }

        async function saveTemplateToStorage(arrayBuffer) {
            try {
                const db = await openTemplateDB();
                const transaction = db.transaction([TEMPLATE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(TEMPLATE_STORE_NAME);

                await new Promise((resolve, reject) => {
                    const request = store.put(arrayBuffer, TEMPLATE_KEY);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });

                console.log('✅ Template PDF sauvegardé (IndexedDB)');
                db.close();
            } catch (e) {
                console.error('Erreur sauvegarde template:', e);
            }
        }

        async function loadTemplateFromStorage() {
            try {
                const db = await openTemplateDB();
                const transaction = db.transaction([TEMPLATE_STORE_NAME], 'readonly');
                const store = transaction.objectStore(TEMPLATE_STORE_NAME);

                const arrayBuffer = await new Promise((resolve, reject) => {
                    const request = store.get(TEMPLATE_KEY);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                db.close();

                if (arrayBuffer) {
                    console.log('✅ Template PDF chargé depuis IndexedDB');
                    return arrayBuffer;
                }
                return null;
            } catch (e) {
                console.error('Erreur chargement template:', e);
                return null;
            }
        }

        async function clearTemplateFromStorage() {
            try {
                const db = await openTemplateDB();
                const transaction = db.transaction([TEMPLATE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(TEMPLATE_STORE_NAME);

                await new Promise((resolve, reject) => {
                    const request = store.delete(TEMPLATE_KEY);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });

                db.close();
                console.log('✅ Template supprimé');
            } catch (e) {
                console.error('Erreur suppression template:', e);
            }
        }

        // Load template on startup
        (async () => {
            cachedTemplate = await loadTemplateFromStorage();
        })();

        window.app.clearTemplate = async () => {
            if (confirm('Supprimer le template PDF enregistré ?\n\nVous devrez en sélectionner un nouveau lors de la prochaine impression.')) {
                await clearTemplateFromStorage();
                cachedTemplate = null;
                alert('Template supprimé. Vous devrez en sélectionner un nouveau.');
            }
        };

        window.app.exportParticipantPDF = async (participantId) => {
            try {
                const participant = (await participantService.getAllParticipants()).find(p => p.id === participantId);
                if (!participant) return;

                // Helper to generate and download
                const processExport = async (templateBuffer) => {
                    try {
                        // Get attendance data
                        const monthInput = document.getElementById('dashboard-month');
                        const monthValue = monthInput ? monthInput.value : new Date().toISOString().slice(0, 7);

                        const allAttendance = await dbService.getAll(STORES.ATTENDANCE);
                        const participantAttendance = allAttendance.filter(r =>
                            r.participantId === participantId &&
                            r.date && r.date.startsWith(monthValue)
                        );

                        // Prompt for signature date and correction
                        const selectionResult = await window.app.requestSignatureDate();
                        if (!selectionResult) return;

                        const { date: signatureDateRaw, isCorrection, signatureId } = selectionResult;

                        // Convert YYYY-MM-DD to DD.MM.YYYY
                        const [sYear, sMonth, sDay] = signatureDateRaw.split('-');
                        const signatureDate = `${sDay}.${sMonth}.${sYear}`;

                        const filledPdfBytes = await window.pdfGenerator.generatePDF(participant, participantAttendance, templateBuffer, signatureDate, isCorrection, signatureId);

                        // Download
                        const blob = new Blob([filledPdfBytes], { type: 'application/pdf' });
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = `MMT_${participant.lastName}_${participant.firstName}_${monthValue}.pdf`;
                        link.click();
                    } catch (err) {
                        console.error('Error during generation:', err);
                        alert('Erreur: ' + err.message);
                    }
                };

                // Try to use stored PDF first, then cached template, then ask user
                if (participant.originalPdf && participant.originalPdf.byteLength > 0) {
                    console.log('Using stored original PDF for export');
                    await processExport(participant.originalPdf);
                } else if (cachedTemplate) {
                    console.log('Using cached template');
                    await processExport(cachedTemplate);
                } else {
                    // Ask user to select template
                    if (!confirm("Aucun modèle PDF n'est enregistré. Voulez-vous sélectionner le formulaire MMT vierge ?")) return;

                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.pdf';
                    input.onchange = async (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        const buffer = await file.arrayBuffer();
                        cachedTemplate = buffer;
                        saveTemplateToStorage(buffer); // Save permanently
                        await processExport(buffer);
                    };
                    input.click();
                }

            } catch (error) {
                console.error('Error in export flow', error);
                alert('Une erreur est survenue.');
            }
        };

        // Date Selection Helper
        window.app.dateSelectionResolve = null;

        window.app.requestSignatureDate = () => {
            return new Promise((resolve) => {
                window.app.dateSelectionResolve = resolve;

                // Set default to today
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                document.getElementById('input-signature-date').value = `${year}-${month}-${day}`;

                // Reset correction checkbox
                const correctionCb = document.getElementById('input-is-correction');
                if (correctionCb) correctionCb.checked = false;

                // Load signatures dropdown
                loadSignaturesDropdown();

                document.getElementById('modal-date-selection').style.display = 'flex';
            });
        };

        // Dashboard Cell Editing
        window.app.editDashboardCell = async (participantId, date, period, currentCode, currentComment, className) => {
            // Create modal HTML
            const modalHtml = `
                <div id="modal-edit-attendance" style="display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
                    <div style="background: white; padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%;">
                        <h3 style="margin-top: 0;">Modifier la présence</h3>
                        <p style="color: #666; margin-bottom: 1.5rem;">
                            <strong>Date:</strong> ${date}<br>
                            <strong>Période:</strong> ${period === 'morning' ? 'Matin' : 'Après-midi'}<br>
                            <strong>Classe:</strong> ${className}
                        </p>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Code de présence</label>
                            <select id="attendance-code-select" style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 8px; font-size: 1rem;">
                                <option value="" ${!currentCode ? 'selected' : ''}>-- (Vide) --</option>
                                ${Object.values(window.ATTENDANCE_CODES).filter(c => c.code !== '').map(c => `
                                    <option value="${c.code}" ${currentCode === c.code ? 'selected' : ''}>${c.code} - ${c.label}</option>
                                `).join('')}
                            </select>
                        </div>
                        
                        <div id="comment-field" style="margin-bottom: 1.5rem; display: ${currentCode === 'G' ? 'block' : 'none'};">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Commentaire (obligatoire pour code G)</label>
                            <textarea id="attendance-comment" style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 8px; font-size: 1rem; min-height: 80px; font-family: inherit;" placeholder="Précisez la raison...">${currentComment || ''}</textarea>
                        </div>
                        
                        <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                            <button onclick="window.app.closeEditAttendanceModal()" class="btn-secondary">Annuler</button>
                            <button onclick="window.app.saveAttendanceFromDashboard('${participantId}', '${date}', '${period}', '${className}')" class="btn-primary">Enregistrer</button>
                        </div>
                    </div>
                </div>
            `;

            // Remove existing modal if any
            const existingModal = document.getElementById('modal-edit-attendance');
            if (existingModal) existingModal.remove();

            // Add modal to body
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            // Add event listener to show/hide comment field
            const codeSelect = document.getElementById('attendance-code-select');
            const commentField = document.getElementById('comment-field');

            codeSelect.addEventListener('change', (e) => {
                if (e.target.value === 'G') {
                    commentField.style.display = 'block';
                } else {
                    commentField.style.display = 'none';
                }
            });
        };

        window.app.closeEditAttendanceModal = () => {
            const modal = document.getElementById('modal-edit-attendance');
            if (modal) modal.remove();
        };

        window.app.saveAttendanceFromDashboard = async (participantId, date, period, className) => {
            const codeSelect = document.getElementById('attendance-code-select');
            const commentTextarea = document.getElementById('attendance-comment');

            const code = codeSelect.value;
            const comment = commentTextarea.value.trim();

            // Validation for code G
            if (code === 'G' && !comment) {
                alert('Un commentaire est obligatoire pour le code G (Autres absences justifiées).\n\nVeuillez préciser la raison: mariage(3j), naissance(3j), décès proche(3j), funérailles(1j), déménagement(1j), inspection militaire(½-1j), visite médicale, assistance proche malade(3j), entretien ORP, entretien d\'embauche, rendez-vous officiel, essai en entreprise, autre absence autorisée par l\'ORP.');
                return;
            }

            try {
                // Get or create attendance record
                const allAttendance = await dbService.getAll(STORES.ATTENDANCE);
                let record = allAttendance.find(r => r.participantId === participantId && r.date === date);

                if (!record) {
                    record = {
                        id: `${participantId}_${date}`,
                        participantId,
                        date,
                        morningCode: '',
                        afternoonCode: '',
                        comment: ''
                    };
                }

                // Update the appropriate period
                if (period === 'morning') {
                    record.morningCode = code;
                } else {
                    record.afternoonCode = code;
                }

                // Update comment
                record.comment = comment;

                // Save to database
                await attendanceService.saveAttendance([record]);

                // Close modal
                window.app.closeEditAttendanceModal();

                // Refresh dashboard
                renderDashboard();

                console.log('✅ Présence mise à jour depuis le tableau de bord');
            } catch (error) {
                console.error('❌ Erreur lors de la sauvegarde:', error);
                alert('Erreur lors de la sauvegarde de la présence');
            }
        };


        window.app.resolveDateSelection = (result) => {
            document.getElementById('modal-date-selection').style.display = 'none';
            if (window.app.dateSelectionResolve) {
                window.app.dateSelectionResolve(result);
                window.app.dateSelectionResolve = null;
            }
        };

        // Bind to global scope for HTML onclick handlers

        // --- Classes View ---

        // --- Classes View ---

        window.app.loadClasses = async () => {
            const listContainer = document.getElementById('classes-list');
            if (!listContainer) return;

            listContainer.innerHTML = '<p>Chargement...</p>';
            try {
                const classes = await classService.getAllClasses();
                if (classes.length === 0) {
                    listContainer.innerHTML = '<p>Aucune classe. Créez-en une pour commencer.</p>';
                } else {
                    // Sort by ID descending
                    classes.sort((a, b) => b.id.localeCompare(a.id));

                    listContainer.innerHTML = classes.map(c => `
                <div class="class-card">
                    <div style="display:flex; justify-content:space-between; align-items:start;">
                        <h3>${c.name}</h3>
                        <div style="display:flex; gap:0.5rem;">
                            <button class="btn-secondary btn-sm" onclick="window.app.editClass('${c.id}')" title="Modifier">✏️</button>
                            <button class="btn-secondary btn-sm" onclick="window.app.deleteClass('${c.id}')" title="Supprimer" style="color:var(--primary);">🗑️</button>
                        </div>
                    </div>
                    <p>${c.description || ''}</p>
                    <p style="margin-top:0.5rem; font-weight:500; color:#666;">${c.participantIds?.length || 0} participants</p>
                    <div class="card-actions" style="margin-top:1rem;">
                        <button class="btn-primary btn-sm" onclick="window.app.openClassDetails('${c.id}')">Gérer Présences</button>
                    </div>
                </div>
            `).join('');
                }
            } catch (error) {
                console.error('Error loading classes', error);
                listContainer.innerHTML = '<p class="error">Erreur lors du chargement des classes.</p>';
            }
        };

        window.app.lastSelectedSignatureId = ''; // Global state for signature persistence

        const _originalOpenModal = (id) => document.getElementById(id).style.display = 'flex';
        window.app.openModal = async (id) => {
            // Intercept signature modal opening to restore selection
            if (id === 'modal-date-selection') {
                const signatureSelect = document.getElementById('select-signature');
                if (signatureSelect && window.dbService) {
                    try {
                        const signatures = await dbService.getAll('signatures');
                        signatureSelect.innerHTML = '<option value="">Aucune signature</option>';
                        signatures.forEach(sig => {
                            const opt = document.createElement('option');
                            opt.value = sig.id;
                            opt.textContent = sig.name;
                            if (window.app.lastSelectedSignatureId && sig.id === window.app.lastSelectedSignatureId) {
                                opt.selected = true;
                            }
                            signatureSelect.appendChild(opt);
                        });
                        if (window.app.lastSelectedSignatureId) {
                            signatureSelect.value = window.app.lastSelectedSignatureId;
                        }
                    } catch (e) { console.error('Error loading signatures in modal', e); }
                }
            }
            _originalOpenModal(id);
        };

        // Capture signature selection on confirm button click
        document.addEventListener('DOMContentLoaded', () => {
            const confirmBtn = document.querySelector('#modal-date-selection button.btn-primary');
            if (confirmBtn) {
                confirmBtn.addEventListener('click', () => {
                    const select = document.getElementById('select-signature');
                    if (select) {
                        window.app.lastSelectedSignatureId = select.value;
                        console.log('💾 Signature sélectionnée mémorisée:', select.value);
                    }
                });
            }
        });

        // Override deleteParticipant to ensure class cleanup
        window.app.deleteParticipant = async (id) => {
            if (!confirm('Êtes-vous sûr de vouloir supprimer ce participant ?')) return;

            try {
                await participantService.deleteParticipant(id);

                // Clean from classes
                if (window.classService) {
                    const allClasses = await classService.getAllClasses();
                    for (const c of allClasses) {
                        if (c.participantIds && c.participantIds.includes(id)) {
                            c.participantIds = c.participantIds.filter(pid => pid !== id);
                            await classService.updateClass(c);
                            console.log(`Removed ${id} from class ${c.id}`);
                        }
                    }
                }

                loadParticipantsView();
                const dashboardEl = document.getElementById('dashboard');
                if (dashboardEl && dashboardEl.style.display !== 'none') {
                    renderDashboard();
                }
            } catch (e) {
                console.error('Error deleting participant:', e);
                alert('Erreur lors de la suppression.');
            }
        };

        // FIX: Signature Persistence via Observer & Interception
        // 1. Intercept resolution to save selection
        const _originalResolveDateSelection = window.app.resolveDateSelection;
        window.app.resolveDateSelection = (data) => {
            if (data && data.signatureId) {
                window.app.lastSelectedSignatureId = data.signatureId;
                console.log('💾 Signature mémorisée (interception):', data.signatureId);
            }
            if (_originalResolveDateSelection) _originalResolveDateSelection(data);
        };

        // 2. Detect Modal Opening to Restore Selection
        const _sigModal = document.getElementById('modal-date-selection');
        if (_sigModal) {
            const _observer = new MutationObserver(async (mutations) => {
                for (const m of mutations) {
                    if (m.attributeName === 'style' && _sigModal.style.display && _sigModal.style.display !== 'none') {
                        console.log('👀 Modal signature ouvert -> Restauration...');
                        const select = document.getElementById('select-signature');
                        if (select && window.app.lastSelectedSignatureId) {
                            try {
                                // Ensure options are populated if needed
                                if (select.options.length <= 1) {
                                    const signatures = await dbService.getAll('signatures');
                                    select.innerHTML = '<option value="">Aucune signature</option>';
                                    signatures.forEach(sig => {
                                        const opt = document.createElement('option');
                                        opt.value = sig.id;
                                        opt.textContent = sig.name;
                                        select.appendChild(opt);
                                    });
                                }
                                select.value = window.app.lastSelectedSignatureId;
                                console.log('✅ Signature restaurée:', window.app.lastSelectedSignatureId);
                            } catch (e) { console.error(e); }
                        }
                    }
                }
            });
            _observer.observe(_sigModal, { attributes: true });
        }


        // Batch PDF Export
        window.app.exportSelectedParticipantsPDF = async () => {
            const checkboxes = document.querySelectorAll('.participant-batch-cb:checked');
            const ids = Array.from(checkboxes).map(cb => cb.value);

            if (ids.length === 0) {
                alert('Veuillez sélectionner au moins un participant.');
                return;
            }

            // Ask for template
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.pdf';

            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const templateBytes = await file.arrayBuffer();
                    const mergedPdf = await PDFLib.PDFDocument.create();

                    const participants = await participantService.getAllParticipants();
                    const allAttendance = await dbService.getAll(STORES.ATTENDANCE);

                    // Get month
                    const monthInput = document.getElementById('dashboard-month');
                    const monthValue = monthInput ? monthInput.value : new Date().toISOString().slice(0, 7);

                    // Prompt for signature date and correction
                    const selectionResult = await window.app.requestSignatureDate();
                    if (!selectionResult) return;

                    const { date: signatureDateRaw, isCorrection, signatureId } = selectionResult;

                    // Convert YYYY-MM-DD to DD.MM.YYYY
                    const [sYear, sMonth, sDay] = signatureDateRaw.split('-');
                    const signatureDate = `${sDay}.${sMonth}.${sYear}`;

                    let processedCount = 0;

                    for (const id of ids) {
                        const p = participants.find(x => x.id === id);
                        if (!p) continue;

                        const pAttendance = allAttendance.filter(r =>
                            r.participantId === id &&
                            r.date && r.date.startsWith(monthValue)
                        );

                        // Generate individual PDF
                        const filledBytes = await window.pdfGenerator.generatePDF(p, pAttendance, templateBytes, signatureDate, isCorrection, signatureId);
                        // Load it to copy pages
                        const filledPdf = await PDFLib.PDFDocument.load(filledBytes);
                        const copiedPages = await mergedPdf.copyPages(filledPdf, filledPdf.getPageIndices());

                        copiedPages.forEach((page) => mergedPdf.addPage(page));
                        processedCount++;

                        // Ajouter un délai de 100ms entre chaque PDF pour laisser le temps à l'image de se charger
                        if (processedCount < ids.length) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                    }

                    // Save merged PDF
                    const mergedBytes = await mergedPdf.save();
                    const blob = new Blob([mergedBytes], { type: 'application/pdf' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `MMT_Export_Groupe_${monthValue}.pdf`;
                    link.click();

                    alert(`${processedCount} formulaires générés et fusionnés avec succès !`);

                } catch (error) {
                    console.error('Batch export error', error);
                    alert('Erreur lors de l\'exportation groupée: ' + error.message);
                }
            };

            input.click();
        };

        // Generate Monthly Report (Compile all PDFs)
        window.app.generateMonthlyReport = async () => {
            // Open selection modal
            const classes = await classService.getAllClasses();
            const participants = await participantService.getAllParticipants();

            // Identify groups
            // 1. Defined Classes
            // 2. "Sans classe" (participants not in any class)

            // Find participants without class
            const participantsInClasses = new Set();
            classes.forEach(c => {
                if (c.participantIds) c.participantIds.forEach(id => participantsInClasses.add(id));
            });
            const participantsWithoutClass = participants.filter(p => !participantsInClasses.has(p.id));

            const container = document.getElementById('print-class-selection-list');
            container.innerHTML = '';

            // Add "Select All"
            container.innerHTML += `
        <div style="padding: 0.5rem; border-bottom: 2px solid #eee; margin-bottom:0.5rem;">
            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight:bold;">
                <input type="checkbox" onchange="const cbs = document.querySelectorAll('.print-class-cb'); cbs.forEach(cb => cb.checked = this.checked);">
                Tout sélectionner
            </label>
        </div>
    `;

            classes.forEach(c => {
                container.innerHTML += `
            <div style="padding: 0.5rem; border-bottom: 1px solid #eee;">
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="checkbox" class="print-class-cb" value="class:${c.id}">
                    <span style="font-weight:500;">Classe: ${c.name}</span> <span style="color:#666; font-size:0.9em;">(${c.participantIds ? c.participantIds.length : 0} participants)</span>
                </label>
            </div>
        `;
            });

            if (participantsWithoutClass.length > 0) {
                container.innerHTML += `
            <div style="padding: 0.5rem; border-bottom: 1px solid #eee;">
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="checkbox" class="print-class-cb" value="noclass">
                    <span style="font-weight:500;">Sans classe</span> <span style="color:#666; font-size:0.9em;">(${participantsWithoutClass.length} participants)</span>
                </label>
            </div>
        `;
            }

            if (classes.length === 0 && participantsWithoutClass.length === 0) {
                container.innerHTML = '<p>Aucun participant ni classe trouvé.</p>';
            }

            window.app.openModal('modal-print-selection');
        };

        window.app.confirmPrintSelection = async () => {
            const selectedCbs = document.querySelectorAll('.print-class-cb:checked');
            if (selectedCbs.length === 0) {
                alert('Veuillez sélectionner au moins une classe ou un groupe.');
                return;
            }

            const selections = Array.from(selectedCbs).map(cb => cb.value); // ['class:ID', 'noclass']

            // Close modal
            window.app.closeModal('modal-print-selection');

            // Proceed to standard generation logic
            try {
                const monthInput = document.getElementById('dashboard-month');
                const monthValue = monthInput ? monthInput.value : new Date().toISOString().slice(0, 7);

                // Prompt for signature date
                const selectionResult = await window.app.requestSignatureDate();
                if (!selectionResult) return;

                const { date: signatureDateRaw, isCorrection, signatureId } = selectionResult;

                // Convert YYYY-MM-DD to DD.MM.YYYY
                const [sYear, sMonth, sDay] = signatureDateRaw.split('-');
                const signatureDate = `${sDay}.${sMonth}.${sYear}`;

                const allParticipants = await participantService.getAllParticipants();

                // Récupérer les présences via la méthode appropriée
                let allAttendance = [];
                if (dbService.getAttendances) {
                    allAttendance = await dbService.getAttendances();
                } else if (dbService.getAll) {
                    allAttendance = await dbService.getAll(STORES.ATTENDANCE);
                }

                const classes = await classService.getAllClasses();

                // Filter participants based on selection
                let targetParticipants = [];
                const participantsInClassesIds = new Set();

                // Helper to get class participants
                const getClassParticipants = (classId) => {
                    const cls = classes.find(c => c.id === classId);
                    if (!cls || !cls.participantIds) return [];
                    return allParticipants.filter(p => cls.participantIds.includes(p.id));
                };

                for (const sel of selections) {
                    if (sel.startsWith('class:')) {
                        const classId = sel.split(':')[1];
                        const ps = getClassParticipants(classId);
                        targetParticipants.push(...ps);
                    } else if (sel === 'noclass') {
                        // Find those without class
                        classes.forEach(c => {
                            if (c.participantIds) c.participantIds.forEach(id => participantsInClassesIds.add(id));
                        });
                        const noClassPs = allParticipants.filter(p => !participantsInClassesIds.has(p.id));
                        targetParticipants.push(...noClassPs);
                    }
                }

                // Deduplicate
                const uniqueIds = new Set();
                targetParticipants = targetParticipants.filter(p => {
                    if (uniqueIds.has(p.id)) return false;
                    uniqueIds.add(p.id);
                    return true;
                });

                if (targetParticipants.length === 0) {
                    alert('Aucun participant sélectionné.');
                    return;
                }

                // Sort participants
                targetParticipants.sort((a, b) => a.lastName.localeCompare(b.lastName));

                // Check if we need a template
                const needsTemplate = targetParticipants.some(p => !p.originalPdf || p.originalPdf.byteLength === 0);

                // Try refreshing cachedTemplate from DB if missing
                if (needsTemplate && !cachedTemplate && window.dbService && window.dbService.getGlobalTemplate) {
                    console.log('🔄 Tentative de chargement du template global avant demande...');
                    try {
                        const globalTpl = await window.dbService.getGlobalTemplate();
                        if (globalTpl) {
                            cachedTemplate = globalTpl;
                            console.log('✅ Template global récupéré avec succès');
                        }
                    } catch (e) {
                        console.warn('⚠️ Impossible de récupérer le template global:', e);
                    }
                }

                if (needsTemplate && !cachedTemplate) {
                    if (!confirm('Certains participants n\'ont pas de PDF enregistré. Voulez-vous sélectionner le formulaire MMT vierge pour tous ?')) {
                        return;
                    }

                    // Ask for template
                    await new Promise((resolve) => {
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = '.pdf';
                        input.onchange = async (e) => {
                            const file = e.target.files[0];
                            if (file) {
                                cachedTemplate = await file.arrayBuffer();
                                saveTemplateToStorage(cachedTemplate); // Save permanently
                            }
                            resolve();
                        };
                        input.click();
                    });

                    if (!cachedTemplate) {
                        alert('Aucun template sélectionné. Opération annulée.');
                        return;
                    }
                }

                const mergedPdf = await PDFLib.PDFDocument.create();
                let processedCount = 0;
                let missingPdfCount = 0;
                const missingPdfNames = [];
                const generationErrors = [];

                console.log('🏁 Démarrage export PDF avec SignatureID:', signatureId);

                // Start Progress
                window.app.showProgress('Génération des rapports...');

                let progressIndex = 0;

                for (const p of targetParticipants) {
                    // Update progress
                    progressIndex++;
                    window.app.updateProgress(progressIndex, targetParticipants.length, `${p.firstName} ${p.lastName}`);

                    // Use originalPdf if available, otherwise use cached template
                    let templateToUse = null;

                    if (p.originalPdf && p.originalPdf.byteLength > 0) {
                        if (p.originalPdf instanceof ArrayBuffer || ArrayBuffer.isView(p.originalPdf)) {
                            // Create a REAL fresh copy by loading and saving the PDF
                            // This ensures no data is shared between iterations
                            const tempDoc = await PDFLib.PDFDocument.load(p.originalPdf);
                            templateToUse = await tempDoc.save();
                        } else {
                            console.error(`❌ PDF corrompu pour ${p.firstName} ${p.lastName}`);
                            generationErrors.push(`${p.firstName} ${p.lastName}: Données PDF corrompues`);
                            continue;
                        }
                    } else if (cachedTemplate) {
                        // Create a REAL fresh copy of the cached template
                        const tempDoc = await PDFLib.PDFDocument.load(cachedTemplate);
                        templateToUse = await tempDoc.save();
                    } else {
                        console.warn(`❌ Pas de template pour ${p.firstName} ${p.lastName}`);
                        missingPdfNames.push(`${p.firstName} ${p.lastName}`);
                        missingPdfCount++;
                        continue;
                    }

                    const pAttendance = allAttendance.filter(r =>
                        r.participantId === p.id &&
                        r.date && r.date.startsWith(monthValue)
                    );

                    try {
                        const filledBytes = await window.pdfGenerator.generatePDF(p, pAttendance, templateToUse, signatureDate, isCorrection, signatureId);
                        const filledPdf = await PDFLib.PDFDocument.load(filledBytes);
                        const copiedPages = await mergedPdf.copyPages(filledPdf, filledPdf.getPageIndices());
                        copiedPages.forEach((page) => mergedPdf.addPage(page));
                        processedCount++;

                        // Ajouter un délai de 100ms entre chaque PDF pour laisser le temps à l'image de se charger
                        if (processedCount < targetParticipants.length) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                    } catch (err) {
                        console.error(`❌ Erreur pour ${p.lastName}:`, err);
                        generationErrors.push(`${p.firstName} ${p.lastName}: ${err.message}`);
                    }
                }

                if (processedCount === 0) {
                    let msg = 'Aucun PDF n\'a pu être généré.';
                    if (missingPdfNames.length > 0) msg += '\n\n⚠️ PDF manquant pour :\n- ' + missingPdfNames.join('\n- ');
                    if (generationErrors.length > 0) msg += '\n\n❌ Erreurs :\n- ' + generationErrors.join('\n- ');
                    alert(msg);
                    return;
                }

                // Hide Progress
                window.app.hideProgress();

                const mergedBytes = await mergedPdf.save();
                const blob = new Blob([mergedBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const printWindow = window.open(url, '_blank');
                if (!printWindow) alert('Le rapport a été généré mais le popup a été bloqué.');

            } catch (error) {
                window.app.hideProgress();
                console.error('Report generation error', error);
                alert('Erreur: ' + error.message);
            }
        };

        // Helper to convert ArrayBuffer to Base64
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        // Helper to convert Base64 to ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Data Export/Import for Office 365 / OneDrive
        window.app.exportData = async () => {
            try {
                const participants = await participantService.getAllParticipants();
                const classes = await classService.getAllClasses();
                const attendance = await dbService.getAll(STORES.ATTENDANCE);

                // Convert PDF ArrayBuffers to Base64 for JSON storage
                const participantsExport = participants.map(p => {
                    const pCopy = { ...p };
                    if (pCopy.originalPdf) {
                        pCopy.originalPdfBase64 = arrayBufferToBase64(pCopy.originalPdf);
                        delete pCopy.originalPdf; // Remove binary from JSON
                    }
                    return pCopy;
                });

                const data = {
                    version: '1.1',
                    timestamp: new Date().toISOString(),
                    participants: participantsExport,
                    classes,
                    attendance
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `MMT_DATA_${new Date().toISOString().slice(0, 10)}.json`;
                link.click();

                alert('Données exportées avec succès (incluant les fichiers PDF originaux).');
            } catch (error) {
                console.error('Export error', error);
                alert('Erreur lors de l\'exportation.');
            }
        };

        window.app.importData = async () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                if (!confirm('ATTENTION: Cette action va REMPLACER toutes les données actuelles.\n\nVoulez-vous continuer ?')) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    if (!data.participants || !data.attendance) {
                        throw new Error('Format de fichier invalide');
                    }

                    // Restore participants (convert Base64 back to ArrayBuffer)
                    const participantsToRestore = data.participants.map(p => {
                        const pCopy = { ...p };
                        if (pCopy.originalPdfBase64) {
                            pCopy.originalPdf = base64ToArrayBuffer(pCopy.originalPdfBase64);
                            delete pCopy.originalPdfBase64;
                        }
                        return pCopy;
                    });

                    // Upsert data
                    for (const p of participantsToRestore) await participantService.updateParticipant(p.id, p);
                    for (const c of data.classes) await dbService.add(STORES.CLASSES, c);
                    for (const a of data.attendance) await dbService.add(STORES.ATTENDANCE, a);

                    alert('Données importées avec succès !');
                    location.reload();

                } catch (error) {
                    console.error('Import error', error);
                    alert('Erreur lors de l\'importation: ' + error.message);
                }
            };
            input.click();
        };
        window.app.handleClassSubmit = async (e) => {
            e.preventDefault();
            const idInput = document.getElementById('c-id');
            const name = document.getElementById('c-name').value;
            const description = document.getElementById('c-desc').value;

            try {
                if (idInput.value) {
                    // Update
                    const classes = await classService.getAllClasses();
                    const existing = classes.find(c => c.id === idInput.value);
                    if (existing) {
                        await classService.updateClass({ ...existing, name, description });
                    }
                } else {
                    // Create
                    await classService.addClass({ name, description });
                }

                document.getElementById('modal-class').style.display = 'none';
                e.target.reset();
                idInput.value = '';
                document.querySelector('#modal-class h2').textContent = 'Nouvelle Classe';
                document.querySelector('#modal-class button[type="submit"]').textContent = 'Créer';
                window.app.loadClasses();
            } catch (error) {
                console.error('Error saving class', error);
                alert('Erreur lors de la sauvegarde de la classe');
            }
        };

        window.app.editClass = async (id) => {
            const classes = await classService.getAllClasses();
            const c = classes.find(x => x.id === id);
            if (!c) return;

            document.getElementById('c-id').value = c.id;
            document.getElementById('c-name').value = c.name;
            document.getElementById('c-desc').value = c.description || '';

            document.querySelector('#modal-class h2').textContent = 'Modifier Classe';
            document.querySelector('#modal-class button[type="submit"]').textContent = 'Mettre à jour';

            window.app.openModal('modal-class');
        };

        window.app.deleteClass = async (id) => {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette classe ?')) return;
            await classService.deleteClass(id);
            window.app.loadClasses();
        };

        window.app.openClassDetails = async (classId) => {
            loadClassDetails(classId);
        };

        window.app.openClassAttendance = async (classId) => {
            await loadClassDetails(classId);
            // Click the Attendance tab
            const tabBtn = document.querySelector('.tab-btn[data-tab="attendance"]');
            if (tabBtn) tabBtn.click();
        };

        window.app.openManageParticipantsModal = async () => {
            const allP = await participantService.getAllParticipants();
            const classes = await classService.getAllClasses();
            const cls = classes.find(c => c.id === currentClassId);

            const container = document.getElementById('manage-participants-list');
            container.innerHTML = allP.map(p => {
                const isChecked = cls.participantIds && cls.participantIds.includes(p.id);
                return `
            <div style="padding: 0.5rem; border-bottom: 1px solid #eee;">
            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                <input type="checkbox" class="manage-p-cb" value="${p.id}" ${isChecked ? 'checked' : ''}>
                    ${p.firstName} ${p.lastName}
            </label>
            </div>
                `;
            }).join('');

            window.app.openModal('modal-manage-participants');
        };

        window.app.saveClassParticipants = async () => {
            const selectedIds = Array.from(document.querySelectorAll('.manage-p-cb:checked')).map(cb => cb.value);

            const classes = await classService.getAllClasses();
            const cls = classes.find(c => c.id === currentClassId);
            cls.participantIds = selectedIds;

            await classService.updateClass(cls);
            window.app.closeModal('modal-manage-participants');
            loadClassDetails(currentClassId);
        };

        let currentClassId = null;

        async function loadClassDetails(classId) {
            currentClassId = classId;
            // Switch view
            document.querySelectorAll('.view-section').forEach(el => el.style.display = 'none');
            document.getElementById('class-details').style.display = 'block';

            try {
                const classes = await classService.getAllClasses();
                const cls = classes.find(c => c.id === classId);
                if (!cls) return;

                document.getElementById('class-details-title').textContent = cls.name;

                // Load Participants Tab
                loadClassParticipants(cls);

                // Load Attendance Tab (Default to today local)
                const now = new Date();
                const localIso = new Date(now.getTime() - (now.getTimezoneOffset() * 60000)).toISOString().split('T')[0];
                document.getElementById('attendance-date').value = localIso;

                loadAttendanceGrid(cls);

            } catch (error) {
                console.error('Error loading class details', error);
            }
        }

        async function loadClassParticipants(cls) {
            const container = document.getElementById('class-participants-list');
            container.innerHTML = '';

            if (!cls.participantIds || cls.participantIds.length === 0) {
                container.innerHTML = '<p>Aucun participant dans cette classe.</p>';
                return;
            }

            const allParticipants = await participantService.getAllParticipants();
            const classParticipants = allParticipants.filter(p => cls.participantIds.includes(p.id));

            container.innerHTML = classParticipants.map(p => `
                <div class="participant-card">
            <h3>${p.firstName} ${p.lastName}</h3>
            <p>${p.courseType || ''}</p>
        </div>
                `).join('');
        }

        async function loadAttendanceGrid(cls) {
            const grid = document.getElementById('attendance-grid');
            const date = document.getElementById('attendance-date').value;

            // Reset indicator initially
            updateCheckIndicator(false);

            if (!cls.participantIds || cls.participantIds.length === 0) {
                grid.innerHTML = '<p>Ajoutez des participants pour saisir les présences.</p>';
                return;
            }

            const allParticipants = await participantService.getAllParticipants();
            const classParticipants = allParticipants.filter(p => cls.participantIds.includes(p.id));

            // Load existing attendance
            const existingRecords = await attendanceService.getAttendance(cls.id, date);
            const recordMap = new Map(); // Map participantId -> record
            existingRecords.forEach(r => recordMap.set(r.participantId, r));

            // Use the new ATTENDANCE_CODES from attendance.js
            const codes = window.ATTENDANCE_CODES;

            const generateOptions = (selectedValue) => {
                // Shortened descriptions for dropdown
                const shortDescriptions = {
                    'X': 'Sur place',
                    'O': 'En ligne',
                    'A': 'Vacances (autorisation ORP)',
                    'B': 'Maladie/Grossesse (certificat dès 4e jour)',
                    'C': 'Accident (certificat dès 4e jour)',
                    'D': 'Congé maternité/parental',
                    'E': 'Service militaire/civil',
                    'F': 'Gain intermédiaire',
                    'G': 'Autres absences justifiées',
                    'H': 'Jours fériés/Fermeture',
                    'I': 'Absence non justifiée'
                };

                let options = '';
                for (const [code, info] of Object.entries(codes)) {
                    const selected = selectedValue === code ? 'selected' : '';
                    const shortDesc = shortDescriptions[code] || info.label;
                    options += `<option value="${code}" ${selected}>${code} - ${shortDesc}</option>`;
                }
                return options;
            };

            let html = `
            <style>
            /* Compact attendance table */
            .attendance-table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 1rem;
            }
            .attendance-table th {
                background: var(--primary);
                color: white;
                padding: 0.75rem;
                text-align: left;
                font-weight: 600;
            }
            .attendance-table td {
                padding: 0.5rem;
                border-bottom: 1px solid #eee;
            }
            .attendance-table tr:hover {
                background: #f8f9fa;
            }
            /* Compact select - show only code letter */
            .attendance-select {
                width: 50px;
                text-align: center;
                font-weight: bold;
                font-size: 1rem;
                padding: 0.3rem;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
            /* Dropdown options with limited width */
            .attendance-select option {
                text-align: left;
                font-weight: normal;
                white-space: normal;
                padding: 0.5rem;
                max-width: 500px;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            /* Limit dropdown menu width */
            .attendance-select:focus {
                max-width: 500px;
            }
            /* Comment input */
            .attendance-comment {
                width: 100%;
                padding: 0.4rem;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 0.9rem;
            }
            </style>
            <table class="attendance-table">
                <thead>
                    <tr>
                        <th style="width: 30%;">Participant</th>
                        <th style="width: 8%; text-align: center;">Matin</th>
                        <th style="width: 8%; text-align: center;">Après-midi</th>
                        <th style="width: 54%;">Commentaire</th>
                    </tr>
                </thead>
                <tbody>
                    `;

            html += classParticipants.map(p => {
                // Determine default presence based on Schedule
                const currentDayOfWeek = new Date(date).getDay(); // 0 (Sun) to 6 (Sat). Note: Schedule uses 1-5.
                // Schedule keys are '1-am', '2-pm' etc. 0 is Sunday, 6 is Saturday.
                // Assuming Weekends are default OFF. 
                // Convert JS Day (0=Sun, 1=Mon) to Schedule Key (1=Mon). 
                // If weekend, default is empty ? Yes usually.

                let isScheduledAm = true;
                let isScheduledPm = true;

                if (currentDayOfWeek === 0 || currentDayOfWeek === 6) {
                    isScheduledAm = false;
                    isScheduledPm = false;
                } else {
                    // Monday=1...Friday=5
                    if (p.schedule) {
                        isScheduledAm = p.schedule[`${currentDayOfWeek}-am`] !== false; // Default true if undefined? No, usually check property.
                        isScheduledPm = p.schedule[`${currentDayOfWeek}-pm`] !== false;
                        // Actually in parsed schedule, it is boolean.
                        if (p.schedule[`${currentDayOfWeek}-am`] === false) isScheduledAm = false;
                        if (p.schedule[`${currentDayOfWeek}-pm`] === false) isScheduledPm = false;
                    }
                }

                const record = recordMap.get(p.id) || {};
                const morningVal = record.morningCode !== undefined ? record.morningCode : (isScheduledAm ? 'X' : '');
                const afternoonVal = record.afternoonCode !== undefined ? record.afternoonCode : (isScheduledPm ? 'X' : '');
                const commentVal = record.comment || '';

                return `
                    <tr class="attendance-row" data-participant-id="${p.id}">
                        <td><strong>${p.firstName} ${p.lastName}</strong></td>
                        <td style="text-align: center;">
                            <select class="attendance-select" data-pid="${p.id}" data-period="morning" onchange="handleAttendanceCodeChange()">
                                ${generateOptions(morningVal)}
                            </select>
                        </td>
                        <td style="text-align: center;">
                            <select class="attendance-select" data-pid="${p.id}" data-period="afternoon" onchange="handleAttendanceCodeChange()">
                                ${generateOptions(afternoonVal)}
                            </select>
                        </td>
                        <td>
                            <input type="text" class="attendance-comment" data-pid="${p.id}" value="${commentVal}" placeholder="Justification...">
                        </td>
                    </tr>
                    `;
            }).join('');

            html += `
                </tbody>
            </table>
        `;

            grid.innerHTML = html;

            // Apply custom rendering to show only code in select
            document.querySelectorAll('.attendance-select').forEach(select => {
                updateSelectDisplay(select);
                select.addEventListener('change', function () {
                    updateSelectDisplay(this);
                });
            });

            // Check if code G is used and show/hide comment requirement
            handleAttendanceCodeChange();

            // Check if attendance has been marked as checked
            console.log('🔍 Checking if attendance is marked as checked for:', cls.id, date);
            const isChecked = await attendanceService.isChecked(cls.id, date);
            console.log('✅ isChecked result:', isChecked);
            updateCheckIndicator(isChecked);
        }

        // Helper function to display only code in select
        function updateSelectDisplay(selectElement) {
            const selectedOption = selectElement.options[selectElement.selectedIndex];
            if (selectedOption) {
                const code = selectedOption.value;
                // Create a temporary option with just the code
                const tempOption = document.createElement('option');
                tempOption.value = code;
                tempOption.textContent = code;
                tempOption.selected = true;

                // Store original options
                if (!selectElement.dataset.originalHtml) {
                    selectElement.dataset.originalHtml = selectElement.innerHTML;
                }

                // On focus, show full options
                selectElement.addEventListener('focus', function () {
                    this.innerHTML = this.dataset.originalHtml;
                    this.value = code;
                }, { once: false });

                // On blur, show only code
                selectElement.addEventListener('blur', function () {
                    const currentValue = this.value;
                    this.dataset.originalHtml = this.innerHTML;
                    this.innerHTML = '';
                    const opt = document.createElement('option');
                    opt.value = currentValue;
                    opt.textContent = currentValue;
                    opt.selected = true;
                    this.appendChild(opt);
                }, { once: false });

                // Initial display: show only code
                if (!selectElement.matches(':focus')) {
                    selectElement.innerHTML = '';
                    selectElement.appendChild(tempOption);
                }
            }
        }

        // Date change listener
        document.getElementById('attendance-date')?.addEventListener('change', async () => {
            if (currentClassId) {
                const classes = await classService.getAllClasses();
                const cls = classes.find(c => c.id === currentClassId);
                if (cls) loadAttendanceGrid(cls);
            }
        });

        // Date navigation functions (Global to avoid duplicate listeners)
        window.app.handlePrevDate = function (e) {
            e.preventDefault();
            const dateInput = document.getElementById('attendance-date');
            if (!dateInput.value) return;

            const [y, m, d] = dateInput.value.split('-').map(Number);
            const date = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));

            date.setUTCDate(date.getUTCDate() - 1);

            let day = date.getUTCDay();
            if (day === 0) date.setUTCDate(date.getUTCDate() - 2);
            else if (day === 6) date.setUTCDate(date.getUTCDate() - 1);

            dateInput.value = date.toISOString().split('T')[0];
            dateInput.dispatchEvent(new Event('change'));
        };

        window.app.handleNextDate = function (e) {
            e.preventDefault();
            const dateInput = document.getElementById('attendance-date');
            if (!dateInput.value) return;

            const [y, m, d] = dateInput.value.split('-').map(Number);
            const date = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));

            date.setUTCDate(date.getUTCDate() + 1);

            let day = date.getUTCDay();
            if (day === 6) date.setUTCDate(date.getUTCDate() + 2);
            else if (day === 0) date.setUTCDate(date.getUTCDate() + 1);

            dateInput.value = date.toISOString().split('T')[0];
            dateInput.dispatchEvent(new Event('change'));
        };





        // Handle attendance code change - highlight comment fields when code G is used
        window.handleAttendanceCodeChange = function () {
            const rows = document.querySelectorAll('.attendance-row');

            rows.forEach(row => {
                const selects = row.querySelectorAll('.attendance-select');
                const commentInput = row.querySelector('.attendance-comment');
                const morningCode = selects[0]?.value;
                const afternoonCode = selects[1]?.value;

                // Highlight comment field if code G is used for this participant
                if (commentInput) {
                    if (morningCode === 'G' || afternoonCode === 'G') {
                        commentInput.style.backgroundColor = '#fff9c4';
                        commentInput.style.border = '2px solid #ff9800';
                        commentInput.placeholder = 'OBLIGATOIRE pour code G - Précisez la raison';
                        commentInput.required = true;
                    } else {
                        commentInput.style.backgroundColor = '';
                        commentInput.style.border = '';
                        commentInput.placeholder = 'Justification...';
                        commentInput.required = false;
                    }
                }
            });
        };

        // Update check indicator
        function updateCheckIndicator(isChecked) {
            let indicator = document.getElementById('attendance-check');

            if (indicator) {
                if (isChecked) {
                    indicator.innerHTML = '<span style="font-size: 1.5rem; filter: grayscale(1);">✔️</span>';
                    indicator.style.display = 'inline-block';
                    indicator.style.color = '#000000';  // Noir
                    indicator.style.marginLeft = '1rem';
                    indicator.style.padding = '0.5rem 1rem';
                    indicator.style.backgroundColor = '#ffebee';  // Rouge très clair
                    indicator.style.borderRadius = '8px';
                    indicator.style.border = '2px solid #e53935';  // Rouge moyen
                } else {
                    indicator.innerHTML = '';
                    indicator.style.display = 'none';
                }
            } else {
                console.warn('Attendance check indicator element not found');
            }
        }

        // Save Attendance Logic
        window.saveAttendance = async () => {
            if (!currentClassId) return;

            const date = document.getElementById('attendance-date').value;
            const rows = document.querySelectorAll('.attendance-row');
            const records = [];
            let hasError = false;
            const errors = [];

            // Build records and validate
            rows.forEach(row => {
                const participantId = row.dataset.participantId;
                const selects = row.querySelectorAll('select');
                const commentInput = row.querySelector('.attendance-comment');

                const morningCode = selects[0]?.value || 'X';
                const afternoonCode = selects[1]?.value || 'X';
                const comment = commentInput ? commentInput.value.trim() : '';

                // Validation: Comment required if code G is used
                if ((morningCode === 'G' || afternoonCode === 'G') && !comment) {
                    hasError = true;
                    if (commentInput) {
                        commentInput.style.border = '3px solid red';
                    }
                    // Get participant name from the row
                    const nameCell = row.querySelector('td');
                    const participantName = nameCell ? nameCell.textContent : 'Participant';
                    errors.push(participantName);
                } else {
                    if (commentInput) {
                        commentInput.style.border = '';
                    }
                }

                records.push({
                    date,
                    classId: currentClassId,
                    participantId,
                    morningCode,
                    afternoonCode,
                    comment
                });
            });

            if (hasError) {
                alert(`Un commentaire est obligatoire pour le code G(Autres absences justifiées).\n\nParticipants concernés: \n - ${errors.join('\n- ')} \n\nVeuillez préciser la raison: mariage(3j), naissance(3j), décès proche(3j), funérailles(1j), déménagement(1j), inspection militaire(½-1j), visite médicale, assistance proche malade(3j), entretien ORP, entretien d'embauche, rendez-vous officiel, essai en entreprise, autre absence autorisée par l'ORP.`);
                return;
            }

            try {
                await attendanceService.saveAttendance(records);
                console.log('💾 Attendance saved successfully');

                // Mark as checked
                console.log('✔️ Marking attendance as checked for:', currentClassId, date);
                await attendanceService.markAsChecked(currentClassId, date);
                console.log('✅ Marked as checked successfully');

                // Update check indicator
                updateCheckIndicator(true);

                // Rafraîchir le tableau de bord pour afficher les changements
                if (window.renderDashboard) {
                    setTimeout(() => window.renderDashboard(), 100);
                }

                alert('Présences enregistrées avec succès !');
            } catch (error) {
                console.error('Error saving attendance', error);
                alert('Erreur lors de la sauvegarde.');
            }
        };

        // Event Listeners for Class Details
        document.getElementById('btn-back-classes')?.addEventListener('click', () => {
            navigateTo('classes');
        });

        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');

                e.target.classList.add('active');
                document.getElementById(`tab-${e.target.dataset.tab}`).style.display = 'block';
            });
        });

        // Assign Participant Logic
        document.getElementById('btn-add-participant-to-class')?.addEventListener('click', async () => {
            const modal = document.getElementById('modal-assign-participant');
            const list = document.getElementById('assign-participants-list');
            modal.style.display = 'flex';

            // Load candidates (not already in class)
            const allParticipants = await participantService.getAllParticipants();
            const classes = await classService.getAllClasses();
            const currentClass = classes.find(c => c.id === currentClassId);

            const candidates = allParticipants.filter(p => !currentClass.participantIds.includes(p.id));

            if (candidates.length === 0) {
                list.innerHTML = '<p>Tous les participants sont déjà dans cette classe.</p>';
            } else {
                list.innerHTML = candidates.map(p => `
            <div style="padding: 0.5rem; border-bottom: 1px solid #eee;" >
                <input type="checkbox" id="assign-${p.id}" value="${p.id}">
                    <label for="assign-${p.id}">${p.firstName} ${p.lastName}</label>
                </div>
        `).join('');
            }
        });

        document.getElementById('btn-confirm-assign')?.addEventListener('click', async () => {
            const checkboxes = document.querySelectorAll('#assign-participants-list input:checked');
            const ids = Array.from(checkboxes).map(cb => cb.value);

            if (ids.length > 0) {
                for (const id of ids) {
                    await classService.addParticipantToClass(currentClassId, id);
                }
                document.getElementById('modal-assign-participant').style.display = 'none';
                loadClassDetails(currentClassId); // Refresh
            }
        });

        document.getElementById('btn-cancel-assign')?.addEventListener('click', () => {
            document.getElementById('modal-assign-participant').style.display = 'none';
        });

        // PDF Import Logic
        document.getElementById('btn-import-pdf')?.addEventListener('click', () => {
            document.getElementById('modal-import-pdf').style.display = 'flex';
        });

        document.getElementById('btn-cancel-import')?.addEventListener('click', () => {
            document.getElementById('modal-import-pdf').style.display = 'none';
            document.getElementById('import-preview').style.display = 'none';
            document.getElementById('form-import-pdf').reset();
        });







        // Test Mode: Add test participants without PDF
        window.addTestParticipants = async () => {
            const testParticipants = [
                { firstName: 'Jean', lastName: 'Dupont', courseType: 'MARKET0625' },
                { firstName: 'Marie', lastName: 'Martin', courseType: 'MARKET0625' },
                { firstName: 'Pierre', lastName: 'Bernard', courseType: 'DIGITAL0725' },
                { firstName: 'Sophie', lastName: 'Dubois', courseType: 'DIGITAL0725' },
                { firstName: 'Luc', lastName: 'Moreau', courseType: 'MARKET0625' }
            ];

            let importedCount = 0;
            const allParticipants = await participantService.getAllParticipants();

            for (const testData of testParticipants) {
                const exists = allParticipants.find(p =>
                    p.lastName.toLowerCase() === testData.lastName.toLowerCase() &&
                    p.firstName.toLowerCase() === testData.firstName.toLowerCase()
                );

                if (!exists) {
                    await participantService.addParticipant(testData);
                    importedCount++;
                }
            }

            alert(`✅ Mode Test: ${importedCount} participant(s) de test ajouté(s).`);
            document.getElementById('modal-import-pdf').style.display = 'none';
            loadParticipantsView();
        };

        // Duplicate PDF import handler removed - using the one in DOMContentLoaded instead


        window.app.deleteParticipant = async (id) => {
            if (!confirm('Êtes-vous sûr de vouloir supprimer ce participant ?')) return;
            try {
                await participantService.deleteParticipant(id);
                loadParticipantsView();
            } catch (error) {
                console.error('Error deleting participant', error);
                alert('Erreur lors de la suppression du participant');
            }
        };

        window.app.restoreParticipant = async (id) => {
            if (!confirm('Réactiver ce participant ?')) return;
            try {
                const archived = await dbService.getAll('archivedParticipants');
                const participant = archived.find(p => p.id === id);

                if (participant) {
                    // Add back to active participants
                    await participantService.addParticipant(participant);

                    // Remove from archives
                    dbService.data.archivedParticipants = archived.filter(p => p.id !== id);
                    await dbService.save();

                    loadParticipantsView();
                }
            } catch (error) {
                console.error('Error restoring participant', error);
                alert('Erreur lors de la réactivation du participant');
            }
        };

        window.app.deleteArchivedParticipant = async (id) => {
            if (!confirm('Supprimer définitivement ce participant archivé ?\n\nCette action est irréversible.')) return;
            try {
                const archived = await dbService.getAll('archivedParticipants');
                dbService.data.archivedParticipants = archived.filter(p => p.id !== id);
                await dbService.save();
                loadParticipantsView();
            } catch (error) {
                console.error('Error deleting archived participant', error);
                alert('Erreur lors de la suppression du participant archivé');
            }
        };

        window.app.toggleSelectAllArchived = (source) => {
            const checkboxes = document.querySelectorAll('.archived-batch-cb');
            checkboxes.forEach(cb => cb.checked = source.checked);
        };

        window.app.deleteSelectedArchived = async () => {
            const checkboxes = document.querySelectorAll('.archived-batch-cb:checked');
            const ids = Array.from(checkboxes).map(cb => cb.value);

            if (ids.length === 0) {
                alert('Aucun participant archivé sélectionné.');
                return;
            }

            if (!confirm(`Supprimer définitivement ${ids.length} participant(s) archivé(s) ?\n\nCette action est irréversible.`)) return;

            try {
                const archived = await dbService.getAll('archivedParticipants');
                dbService.data.archivedParticipants = archived.filter(p => !ids.includes(p.id));
                await dbService.save();

                // Uncheck "select all"
                const selectAllCb = document.getElementById('cb-select-all-archived');
                if (selectAllCb) selectAllCb.checked = false;

                loadParticipantsView();
            } catch (error) {
                console.error('Error deleting selected archived participants', error);
                alert('Erreur lors de la suppression des participants archivés');
            }
        };

        // ===== SIGNATURE MANAGEMENT =====

        window.app.openSignatureManager = () => {
            window.app.openModal('modal-signature-manager');
            loadSignaturesList();
        };

        window.app.uploadSignature = async () => {
            const nameInput = document.getElementById('new-signature-name');
            const fileInput = document.getElementById('new-signature-file');

            if (!nameInput.value.trim()) {
                alert('Veuillez saisir un nom pour la signature.');
                return;
            }

            if (!fileInput.files || fileInput.files.length === 0) {
                alert('Veuillez sélectionner un fichier image.');
                return;
            }

            const file = fileInput.files[0];

            // Convert to Base64
            const reader = new FileReader();
            reader.onload = async (e) => {
                const signature = {
                    id: crypto.randomUUID(),
                    name: nameInput.value.trim(),
                    imageData: e.target.result, // Base64
                    dateAdded: new Date().toISOString()
                };

                try {
                    // Save to database using appropriate method
                    if (dbService.saveSignature) {
                        await dbService.saveSignature(signature);
                    } else if (dbService.add) {
                        await dbService.add('signatures', signature);
                    } else {
                        // Fallback for direct data access
                        if (!dbService.data.signatures) dbService.data.signatures = [];
                        dbService.data.signatures.push(signature);
                        await dbService.save();
                    }

                    // Reset form
                    nameInput.value = '';
                    fileInput.value = '';

                    // Reload list
                    loadSignaturesList();
                    loadSignaturesDropdown();

                    alert('✅ Signature enregistrée avec succès !');
                } catch (error) {
                    console.error('Error saving signature:', error);
                    alert('❌ Erreur lors de l\'enregistrement de la signature');
                }
            };

            reader.readAsDataURL(file);
        };

        window.app.deleteSignature = async (id) => {
            if (!confirm('Supprimer cette signature ?')) return;

            try {
                if (dbService.deleteSignature) {
                    await dbService.deleteSignature(id);
                } else if (dbService.delete) {
                    await dbService.delete('signatures', id);
                } else {
                    // Fallback for direct data access
                    dbService.data.signatures = dbService.data.signatures.filter(s => s.id !== id);
                    await dbService.save();
                }

                loadSignaturesList();
                loadSignaturesDropdown();
            } catch (error) {
                console.error('Error deleting signature', error);
                alert('Erreur lors de la suppression de la signature');
            }
        };

        async function loadSignaturesList() {
            const container = document.getElementById('signatures-list');
            if (!container) return;

            let signatures = [];
            if (dbService.getSignatures) {
                signatures = await dbService.getSignatures();
            } else if (dbService.getAll) {
                signatures = await dbService.getAll('signatures');
            }

            if (signatures.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Aucune signature enregistrée.</p>';
                return;
            }

            container.innerHTML = signatures.map(sig => `
                <div style="padding: 1rem; border: 1px solid #eee; border-radius: 8px; margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center;">
                    <div style="flex: 1;">
                        <strong>${sig.name}</strong>
                        <div style="margin-top: 0.5rem; padding: 0.5rem; background: #f9f9f9; border-radius: 4px;">
                            <img src="${sig.imageData}" style="max-width: 200px; max-height: 40px; display: block;" />
                        </div>
                    </div>
                    <button class="btn-secondary btn-sm" onclick="window.app.deleteSignature('${sig.id}')" style="color: var(--danger);" title="Supprimer">
                        🗑️
                    </button>
                </div>
            `).join('');
        }

        async function loadSignaturesDropdown() {
            const select = document.getElementById('select-signature');
            if (!select) return;

            let signatures = [];
            if (dbService.getSignatures) {
                signatures = await dbService.getSignatures();
            } else if (dbService.getAll) {
                signatures = await dbService.getAll('signatures');
            }

            console.log('📋 Chargement dropdown signatures:', signatures.length, 'trouvée(s)');

            // Keep first option (Aucune signature)
            select.innerHTML = '<option value="">Aucune signature</option>';

            signatures.forEach(sig => {
                const option = document.createElement('option');
                option.value = sig.id;
                option.textContent = sig.name;
                select.appendChild(option);
            });

            console.log('✅ Dropdown signatures chargé avec', signatures.length, 'option(s)');
        }

        // Signature preview on selection change
        document.addEventListener('DOMContentLoaded', () => {
            const select = document.getElementById('select-signature');
            const preview = document.getElementById('signature-preview');
            const previewImg = document.getElementById('signature-preview-img');

            if (select && preview && previewImg) {
                select.addEventListener('change', async () => {
                    const sigId = select.value;

                    if (!sigId) {
                        preview.style.display = 'none';
                        return;
                    }

                    let signatures = [];
                    if (dbService.getSignatures) {
                        signatures = await dbService.getSignatures();
                    } else if (dbService.getAll) {
                        signatures = await dbService.getAll('signatures');
                    }

                    const signature = signatures.find(s => s.id === sigId);

                    if (signature) {
                        previewImg.src = signature.imageData;
                        preview.style.display = 'block';
                    } else {
                        preview.style.display = 'none';
                    }
                });
            }
        });

        // ===== END SIGNATURE MANAGEMENT =====

        // Ensure all window.app methods are available
        window.app.saveAttendance = window.saveAttendance;
        window.app.loadParticipants = loadParticipantsView;
        window.app.generateTestData = window.addTestParticipants;

        // ===== FONCTIONS DE SAUVEGARDE ET CHARGEMENT MANUEL =====

        /**
         * Télécharge une sauvegarde JSON de la base de données
         */
        window.app.downloadDatabaseBackup = function () {
            try {
                // Créer le contenu JSON
                const dataStr = JSON.stringify(dbService.data, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });

                // Créer un lien de téléchargement
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                // Nom du fichier avec date
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
                const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
                a.download = `mmt_db_backup_${dateStr}_${timeStr}.json`;

                // Déclencher le téléchargement
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('✅ Sauvegarde téléchargée avec succès');

                // Feedback visuel
                const btn = event.target.closest('button');
                if (btn) {
                    const originalText = btn.innerHTML;
                    btn.innerHTML = '✅ Sauvegardé';
                    btn.style.background = '#4CAF50';
                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.style.background = '#4CAF50';
                    }, 2000);
                }
            } catch (error) {
                console.error('❌ Erreur lors du téléchargement de la sauvegarde:', error);
                alert('Erreur lors de la création de la sauvegarde.\n\n' + error.message);
            }
        };

        /**
         * Gère la sélection d'un fichier pour restaurer les données
         */
        document.getElementById('data-file-input')?.addEventListener('change', function (e) {
            const file = e.target.files[0];
            const previewDiv = document.getElementById('load-data-preview');
            const confirmBtn = document.getElementById('btn-confirm-load');

            if (!file) {
                previewDiv.style.display = 'none';
                confirmBtn.disabled = true;
                return;
            }

            // Lire le fichier
            const reader = new FileReader();
            reader.onload = function (event) {
                try {
                    const jsonData = JSON.parse(event.target.result);

                    // Valider la structure
                    if (!jsonData.participants || !jsonData.classes || !jsonData.attendance) {
                        throw new Error('Structure du fichier invalide. Le fichier doit contenir : participants, classes, attendance');
                    }

                    // Afficher l'aperçu
                    document.getElementById('preview-participants-count').textContent = jsonData.participants.length;
                    document.getElementById('preview-classes-count').textContent = jsonData.classes.length;
                    document.getElementById('preview-attendance-count').textContent = jsonData.attendance.length;

                    previewDiv.style.display = 'block';
                    confirmBtn.disabled = false;

                    // Stocker les données dans un attribut temporaire
                    confirmBtn.dataset.pendingData = event.target.result;

                } catch (error) {
                    alert('❌ Erreur de lecture du fichier :\n\n' + error.message + '\n\nAssurez-vous que le fichier est un JSON valide.');
                    previewDiv.style.display = 'none';
                    confirmBtn.disabled = true;
                    e.target.value = ''; // Réinitialiser l'input
                }
            };

            reader.onerror = function () {
                alert('❌ Impossible de lire le fichier');
                previewDiv.style.display = 'none';
                confirmBtn.disabled = true;
            };

            reader.readAsText(file);
        });

        /**
         * Charge les données depuis le fichier sélectionné
         */
        window.app.loadDatabaseFromFile = async function () {
            const confirmBtn = document.getElementById('btn-confirm-load');
            const pendingData = confirmBtn.dataset.pendingData;

            if (!pendingData) {
                alert('Aucune donnée à charger');
                return;
            }

            // Confirmation finale
            const participantsCount = document.getElementById('preview-participants-count').textContent;
            const classesCount = document.getElementById('preview-classes-count').textContent;
            const attendanceCount = document.getElementById('preview-attendance-count').textContent;

            const confirmMsg = `⚠️ ATTENTION ⚠️\n\nVous allez remplacer toutes les données actuelles par :\n\n` +
                `• ${participantsCount} participants\n` +
                `• ${classesCount} classes\n` +
                `• ${attendanceCount} enregistrements de présence\n\n` +
                `Cette action est IRRÉVERSIBLE !\n\n` +
                `Voulez-vous continuer ?`;

            if (!confirm(confirmMsg)) {
                return;
            }

            try {
                // Charger les nouvelles données
                const newData = JSON.parse(pendingData);
                dbService.data = newData;

                // Sauvegarder (si possible)
                try {
                    await dbService.save();
                    console.log('✅ Données sauvegardées automatiquement');
                } catch (saveError) {
                    console.warn('⚠️ Sauvegarde automatique échouée (normal sur OneDrive Web):', saveError);
                }

                // Fermer le modal
                window.app.closeModal('modal-load-data');

                // Réinitialiser le formulaire
                document.getElementById('data-file-input').value = '';
                document.getElementById('load-data-preview').style.display = 'none';
                confirmBtn.disabled = true;
                delete confirmBtn.dataset.pendingData;

                // Recharger la vue actuelle
                const currentView = document.querySelector('.view-section:not([style*="display: none"])');
                if (currentView) {
                    const viewId = currentView.id;
                    if (viewId === 'dashboard') {
                        renderDashboard();
                    } else if (viewId === 'participants') {
                        loadParticipantsView();
                    } else if (viewId === 'classes') {
                        if (window.app.loadClasses) {
                            window.app.loadClasses();
                        }
                    }
                }

                alert('✅ Données chargées avec succès !\n\n' +
                    `${participantsCount} participants\n` +
                    `${classesCount} classes\n` +
                    `${attendanceCount} présences`);

            } catch (error) {
                console.error('❌ Erreur lors du chargement des données:', error);
                alert('❌ Erreur lors du chargement des données :\n\n' + error.message);
            }
        };

        /**
         * Fonction générique pour ouvrir un modal (si elle n'existe pas déjà)
         */
        if (!window.app.openModal) {
            window.app.openModal = function (modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.style.display = 'flex';
                }
            };
        }

        /**
         * Fonction générique pour fermer un modal (si elle n'existe pas déjà)
         */
        if (!window.app.closeModal) {
            window.app.closeModal = function (modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.style.display = 'none';
                }
            };
        }

        // ===== GESTION DE LA SIGNATURE POUR LES PDFs =====

        // Stockage global de la signature (en base64)
        window.signatureImageData = null;
        window.signatureUploadResolve = null;

        /**
         * Gestion de l'input file pour la signature
         */
        document.getElementById('signature-image-input')?.addEventListener('change', async function (e) {
            const file = e.target.files[0];
            if (!file) return;

            // Vérifier le type de fichier
            if (!file.type.match('image/(png|jpeg|jpg)')) {
                alert('⚠️ Format non supporté. Veuillez utiliser une image PNG ou JPEG.');
                e.target.value = '';
                return;
            }

            // Vérifier la taille (max 2MB)
            if (file.size > 2 * 1024 * 1024) {
                alert('⚠️ L\'image est trop grande. Taille maximum : 2 Mo.');
                e.target.value = '';
                return;
            }

            try {
                // Lire l'image
                const reader = new FileReader();
                reader.onload = function (event) {
                    const base64Data = event.target.result;

                    // Stocker temporairement
                    window.signatureImageData = base64Data;

                    // Afficher l'aperçu
                    document.getElementById('signature-preview-img').src = base64Data;
                    document.getElementById('signature-preview-container').style.display = 'block';

                    // Activer le bouton de confirmation
                    document.getElementById('btn-confirm-signature').disabled = false;
                };
                reader.readAsDataURL(file);

            } catch (error) {
                console.error('Erreur lors de la lecture de l\'image:', error);
                alert('❌ Erreur lors de la lecture de l\'image : ' + error.message);
            }
        });

        /**
         * Efface la signature sélectionnée
         */
        window.app.clearSignature = function () {
            window.signatureImageData = null;
            document.getElementById('signature-image-input').value = '';
            document.getElementById('signature-preview-container').style.display = 'none';
            document.getElementById('btn-confirm-signature').disabled = false; // On peut quand même continuer sans signature
        };

        /**
         * Continue sans signature
         */
        window.app.continueWithoutSignature = function () {
            window.signatureImageData = null;
            window.app.closeModal('modal-signature-upload');

            // Réinitialiser
            document.getElementById('signature-image-input').value = '';
            document.getElementById('signature-preview-container').style.display = 'none';

            // Résoudre la promesse si elle existe
            if (window.signatureUploadResolve) {
                window.signatureUploadResolve(null);
                window.signatureUploadResolve = null;
            }
        };

        /**
         * Continue avec la signature sélectionnée
         */
        window.app.continueWithSignature = function () {
            if (!window.signatureImageData) {
                alert('⚠️ Veuillez d\'abord sélectionner une image de signature.');
                return;
            }

            window.app.closeModal('modal-signature-upload');

            // Résoudre la promesse avec la signature
            if (window.signatureUploadResolve) {
                window.signatureUploadResolve(window.signatureImageData);
                window.signatureUploadResolve = null;
            }
        };

        /**
         * Demande à l'utilisateur d'uploader une signature (retourne une Promise)
         */
        window.app.requestSignatureUpload = function () {
            return new Promise((resolve) => {
                // Stocker la fonction resolve pour l'appeler plus tard
                window.signatureUploadResolve = resolve;

                // Ouvrir le modal
                window.app.openModal('modal-signature-upload');
            });
        };








        // Global variable for cached template
        window.cachedTemplate = null;

        // Global function to save template
        window.saveTemplateToStorage = async function (templateBuffer) {
            try {
                // Save to Firestore if available
                if (window.dbService && window.dbService.saveGlobalTemplate) {
                    await window.dbService.saveGlobalTemplate(templateBuffer);
                    alert('✅ Modèle PDF sauvegardé en ligne pour tous les utilisateurs.');
                } else {
                    console.warn('DbService not available for saving template');
                }
            } catch (err) {
                console.error('Error saving template:', err);
                alert('Erreur lors de la sauvegarde du modèle en ligne.');
            }
        };

        // Manual Template Upload Function
        window.app.uploadGlobalTemplate = async function () {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.pdf';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const buffer = await file.arrayBuffer();
                        await window.saveTemplateToStorage(buffer);
                        // Update cache immediately
                        window.cachedTemplate = buffer;
                        console.log('✅ Template local updated from manual upload');
                    } catch (err) {
                        console.error('Error reading file:', err);
                        alert('Erreur de lecture du fichier PDF.');
                    }
                }
            };
            input.click();
        };
    </script>

    <!-- Footer -->
    <footer style="
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(to right, #f8f9fa, #e9ecef);
        padding: 0.6rem 1rem;
        text-align: center;
        font-size: 0.65rem;
        color: #6c757d;
        border-top: 1px solid #dee2e6;
        z-index: 100;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
    ">
        Made for Formation Emploi | <strong>MMT Presence Manager v1.0</strong> | by Paul Schaffner
    </footer>

    <!-- Firebase Authentication -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, collection, doc, getDoc, getDocs, setDoc, deleteDoc, updateDoc, addDoc, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        const firebaseConfig = {
            apiKey: "AIzaSyC9Jp7YGeYxYja5rIRXSdVQFvVMmiMU7Ko",
            authDomain: "mmt-presences-app.firebaseapp.com",
            projectId: "mmt-presences-app",
            storageBucket: "mmt-presences-app.firebasestorage.app",
            messagingSenderId: "859089098904",
            appId: "1:859089098904:web:4dc75d1d2813509278d8ed"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- FIREBASE ADAPTER DEFINITION ---
        class FirebaseStorageAdapter {
            constructor() {
                this.cache = {};
                this.initialized = false;
            }

            async init() {
                if (this.initialized) return;
                try {
                    // Load Participants
                    const participantsSnap = await getDocs(collection(db, 'participants'));
                    const participants = [];
                    participantsSnap.forEach(doc => participants.push({ id: doc.id, ...doc.data() }));
                    this.cache.participants = participants;

                    // Load Classes
                    const classesSnap = await getDocs(collection(db, 'classes'));
                    const classes = [];
                    classesSnap.forEach(doc => classes.push({ id: doc.id, ...doc.data() }));
                    this.cache.classes = classes;

                    // Load Attendance
                    const attendancesSnap = await getDocs(collection(db, 'attendances'));
                    const attendances = [];
                    attendancesSnap.forEach(doc => attendances.push({ id: doc.id, ...doc.data() }));
                    this.cache.attendances = attendances;

                    this.initialized = true;
                    console.log('✅ Firebase cache initialized');
                } catch (error) {
                    console.error('❌ Error initializing Firebase cache:', error);
                    this.loadFromLocalStorage();
                }
            }

            loadFromLocalStorage() {
                this.cache.participants = JSON.parse(localStorage.getItem('participants') || '[]');
                this.cache.classes = JSON.parse(localStorage.getItem('classes') || '[]');
                this.cache.attendances = JSON.parse(localStorage.getItem('attendances') || '[]');
                console.log('⚠️ Loaded from localStorage (fallback)');
            }

            async getParticipants() { await this.init(); return this.cache.participants || []; }

            async saveParticipant(participant) {
                await this.init();
                try {
                    // Clone to avoid mutating the original object used by the app / cache
                    const pToSave = { ...participant };

                    // Convert ArrayBuffer to Base64 for Firestore
                    if (pToSave.originalPdf && pToSave.originalPdf instanceof ArrayBuffer) {
                        let binary = '';
                        const bytes = new Uint8Array(pToSave.originalPdf);
                        const len = bytes.byteLength;
                        for (let i = 0; i < len; i++) {
                            binary += String.fromCharCode(bytes[i]);
                        }
                        pToSave.originalPdf = window.btoa(binary);
                        pToSave.isBase64Pdf = true;
                    }

                    if (pToSave.id) {
                        const docRef = doc(db, 'participants', pToSave.id);
                        await setDoc(docRef, pToSave);
                        const index = this.cache.participants.findIndex(p => p.id === participant.id);
                        if (index !== -1) this.cache.participants[index] = participant;
                        else this.cache.participants.push(participant);
                    } else {
                        const docRef = await addDoc(collection(db, 'participants'), pToSave);
                        participant.id = docRef.id;
                        this.cache.participants.push(participant);
                    }
                    return participant;
                } catch (error) { console.error('❌ Error saving participant:', error); throw error; }
            }

            async deleteParticipant(participantId) {
                await this.init();
                try {
                    await deleteDoc(doc(db, 'participants', participantId));
                    this.cache.participants = this.cache.participants.filter(p => p.id !== participantId);
                } catch (error) { console.error('❌ Error deleting participant:', error); throw error; }
            }

            async getClasses() { await this.init(); return this.cache.classes || []; }

            // Archived Participants Support for Firebase
            async getArchivedParticipants() {
                await this.init();
                // If we want to support archives in Firebase, we should probably have a collection
                // For now, let's try to fetch if it exists, or return empty
                try {
                    const snap = await getDocs(collection(db, 'archivedParticipants'));
                    const archived = [];
                    snap.forEach(doc => archived.push({ id: doc.id, ...doc.data() }));
                    return archived;
                } catch (e) {
                    console.warn('Archives not supported or empty in Firebase yet');
                    return [];
                }
            }

            async saveArchivedParticipant(participant) {
                await this.init();
                try {
                    const docRef = doc(db, 'archivedParticipants', participant.id);
                    await setDoc(docRef, participant);
                    return participant;
                } catch (e) { console.error('Error saving archive', e); throw e; }
            }

            async deleteArchivedParticipant(id) {
                await this.init();
                try {
                    await deleteDoc(doc(db, 'archivedParticipants', id));
                } catch (e) { console.error('Error deleting archive', e); throw e; }
            }

            // Signatures Support for Firebase
            async getSignatures() {
                await this.init();

                // Retourner depuis le cache si disponible
                if (this.cache.signatures && this.cache.signatures.length > 0) {
                    return this.cache.signatures;
                }

                try {
                    const snap = await getDocs(collection(db, 'signatures'));
                    const signatures = [];
                    snap.forEach(doc => signatures.push({ id: doc.id, ...doc.data() }));
                    this.cache.signatures = signatures;
                    return signatures;
                } catch (e) {
                    console.warn('Signatures collection not found or empty');
                    return [];
                }
            }

            async saveSignature(signature) {
                await this.init();
                try {
                    const docRef = doc(db, 'signatures', signature.id);
                    await setDoc(docRef, signature);

                    // Mettre à jour le cache local
                    if (!this.cache.signatures) this.cache.signatures = [];
                    const index = this.cache.signatures.findIndex(s => s.id === signature.id);
                    if (index !== -1) {
                        this.cache.signatures[index] = signature;
                    } else {
                        this.cache.signatures.push(signature);
                    }

                    console.log('✅ Signature saved to Firebase');
                    return signature;
                } catch (e) {
                    console.error('❌ Error saving signature:', e);
                    throw e;
                }
            }

            async deleteSignature(id) {
                await this.init();
                try {
                    await deleteDoc(doc(db, 'signatures', id));
                    console.log('✅ Signature deleted from Firebase');
                } catch (e) {
                    console.error('❌ Error deleting signature:', e);
                    throw e;
                }
            }

            async saveClass(classItem) {
                await this.init();
                try {
                    if (classItem.id) {
                        const docRef = doc(db, 'classes', classItem.id);
                        await setDoc(docRef, classItem);
                        const index = this.cache.classes.findIndex(c => c.id === classItem.id);
                        if (index !== -1) this.cache.classes[index] = classItem;
                        else this.cache.classes.push(classItem);
                    } else {
                        const docRef = await addDoc(collection(db, 'classes'), classItem);
                        classItem.id = docRef.id;
                        this.cache.classes.push(classItem);
                    }
                    return classItem;
                } catch (error) { console.error('❌ Error saving class:', error); throw error; }
            }

            async deleteClass(classId) {
                await this.init();
                try {
                    await deleteDoc(doc(db, 'classes', classId));
                    this.cache.classes = this.cache.classes.filter(c => c.id !== classId);
                } catch (error) { console.error('❌ Error deleting class:', error); throw error; }
            }

            // Template Management for Collaboration (Using participants collection for guaranteed access)
            async getGlobalTemplate() {
                await this.init();
                try {
                    // Use a special ID in participants collection to ensure permission access
                    const docRef = doc(db, 'participants', 'GLOBAL_TEMPLATE_CONFIG');
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        if (data.templateBase64) {
                            // Convert Base64 back to ArrayBuffer
                            const binaryParams = window.atob(data.templateBase64);
                            const bytes = new Uint8Array(binaryParams.length);
                            for (let i = 0; i < binaryParams.length; i++) {
                                bytes[i] = binaryParams.charCodeAt(i);
                            }
                            return bytes.buffer;
                        }
                    }
                    return null;
                } catch (error) {
                    console.warn('⚠️ No global template found or error fetching from participants:', error);
                    return null;
                }
            }

            async saveGlobalTemplate(arrayBuffer) {
                await this.init();
                try {
                    // Convert ArrayBuffer to Base64
                    let binary = '';
                    const bytes = new Uint8Array(arrayBuffer);
                    const len = bytes.byteLength;
                    for (let i = 0; i < len; i++) {
                        binary += String.fromCharCode(bytes[i]);
                    }
                    const base64 = window.btoa(binary);

                    // Save as a special participant document
                    await setDoc(doc(db, 'participants', 'GLOBAL_TEMPLATE_CONFIG'), {
                        firstName: 'SYSTEM',
                        lastName: 'TEMPLATE',
                        type: 'CONFIG', // Flag to identify it's not a real person
                        templateBase64: base64,
                        updatedAt: new Date().toISOString(),
                        updatedBy: auth.currentUser ? auth.currentUser.email : 'unknown'
                    });
                    console.log('✅ Global template saved to Firebase (participants collection)');
                } catch (error) {
                    console.error('❌ Error saving global template:', error);
                    throw error;
                }
            }

            async getAttendances() { await this.init(); return this.cache.attendances || []; }

            async saveAttendances(attendances) {
                await this.init();
                try {
                    for (const attendance of attendances) {
                        if (attendance.id) {
                            const docRef = doc(db, 'attendances', attendance.id);
                            await setDoc(docRef, attendance);
                        } else {
                            const docRef = await addDoc(collection(db, 'attendances'), attendance);
                            attendance.id = docRef.id;
                        }
                    }

                    // Mettre à jour le cache local
                    for (const attendance of attendances) {
                        const index = this.cache.attendances.findIndex(a => a.id === attendance.id);
                        if (index !== -1) {
                            this.cache.attendances[index] = attendance;
                        } else {
                            this.cache.attendances.push(attendance);
                        }
                    }

                    console.log('✅ Attendances saved to Firebase');
                } catch (error) { console.error('❌ Error saving attendances:', error); throw error; }
            }

            // Generic getAll for backward compatibility
            async getAll(storeName) {
                switch (storeName) {
                    case 'participants': return this.getParticipants();
                    case 'classes': return this.getClasses();
                    case 'attendances': return this.getAttendances();
                    case 'signatures': return this.getSignatures();
                    case 'archivedParticipants': return this.getArchivedParticipants();
                    default:
                        console.warn(`getAll called with unknown store: ${storeName}`);
                        return [];
                }
            }
        }

        // Instantiate Adapter
        window.firebaseStorage = new FirebaseStorageAdapter();
        console.log('🔥 Firebase Storage Adapter loaded via Module Script');

        // Rendre db accessible globalement
        window.firebaseDb = db;

        // Vérifier l'authentification
        onAuthStateChanged(auth, (user) => {
            if (!user) {
                // Pas connecté, rediriger vers login
                window.location.href = 'login.html';
            } else {
                // Connecté
                console.log('✅ Utilisateur connecté:', user.email);
                window.currentUser = user;

                // Afficher l'email dans la navbar
                const userEmailEl = document.getElementById('user-email');
                if (userEmailEl) {
                    userEmailEl.textContent = user.email;
                }

                // Recharger les données depuis Firestore maintenant que l'utilisateur est connecté
                if (window.dbService) {
                    console.log('🔄 Rechargement des données depuis Firestore...');
                    const reloadPromise = window.dbService.loadFromFile
                        ? window.dbService.loadFromFile()
                        : (window.dbService.init ? window.dbService.init() : Promise.resolve());

                    reloadPromise.then(() => {
                        console.log('✅ Données rechargées');
                        // Rafraîchir l'affichage si on est sur le dashboard
                        if (window.renderDashboard) window.renderDashboard();

                        // Load Global Template
                        if (window.dbService && window.dbService.getGlobalTemplate) {
                            console.log('🔄 Chargement du template global...');
                            window.dbService.getGlobalTemplate().then(template => {
                                if (template) {
                                    window.cachedTemplate = template;
                                    console.log('✅ Template global chargé');
                                }
                            });
                        }
                        // Also try to refresh the active view if possible
                        const participantsView = document.getElementById('participants-view');
                        if (window.loadParticipantsView && participantsView && participantsView.style.display !== 'none') {
                            window.loadParticipantsView();
                        }
                    });
                }
            }
        });

        // Fonction de déconnexion globale
        window.firebaseLogout = async function () {
            if (confirm('Voulez-vous vraiment vous déconnecter ?')) {
                try {
                    await signOut(auth);
                    window.location.href = 'login.html';
                } catch (error) {
                    console.error('❌ Erreur de déconnexion:', error);
                    alert('Erreur lors de la déconnexion');
                }
            }
        };
    </script>

    <!-- Modal Progress Bar -->
    <div id="modal-progress" class="modal" style="display: none; z-index: 9999; background: rgba(0,0,0,0.7);">
        <div
            style="text-align: center; max-width: 400px; padding: 2.5rem; background: white; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.2);">
            <h3 id="progress-title" style="margin-bottom: 1.5rem; font-size: 1.3rem; color: #333;">Traitement en
                cours...</h3>
            <div
                style="background: #e9ecef; border-radius: 20px; height: 12px; width: 100%; overflow: hidden; margin-bottom: 0.8rem; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);">
                <div id="progress-bar-fill"
                    style="background: linear-gradient(90deg, #4CAF50, #81C784); height: 100%; width: 0%; transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);">
                </div>
            </div>
            <p id="progress-text" style="color: #666; font-size: 0.95rem; font-weight: 500;">0%</p>
        </div>
    </div>

    <script>
        // Progress Bar Helpers
        window.app.showProgress = (title) => {
            const modal = document.getElementById('modal-progress');
            document.getElementById('progress-title').textContent = title || 'Veuillez patienter...';
            document.getElementById('progress-bar-fill').style.width = '0%';
            document.getElementById('progress-text').textContent = '0%';
            modal.style.display = 'flex';
        };

        window.app.updateProgress = (current, total, message) => {
            const percent = total > 0 ? Math.round((current / total) * 100) : 0;
            document.getElementById('progress-bar-fill').style.width = `${percent}%`;
            document.getElementById('progress-text').textContent = message ? `${percent}% - ${message}` : `${percent}%`;
        };

        window.app.hideProgress = () => {
            document.getElementById('modal-progress').style.display = 'none';
        };
    </script>
</body>

</html>